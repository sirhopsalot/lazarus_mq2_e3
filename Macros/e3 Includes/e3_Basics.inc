|------------------------------
|- Only bots in the same zone will engage follow.
|- Bots will wait to engage follow until, they can see the FollowTarget, and it is within the MaxResponseDist.
|- If bots are assisting, they will back off and follow until re-engage.
|- @param line: The line that called the event
|- @param ChatSender: The PC who sent the command
|- @param eventParams: Who to follow and /only,/not specifications
|------------------------------
#EVENT Follow "[#1#] Follow"
#EVENT Follow "<#1#> Follow"
#EVENT Follow "#1# tells you, 'Follow#2#'"
#EVENT Follow "#1# tells the group, 'Follow#2#'"
#EVENT Follow "#1# tell your party, 'Follow#2#'"
#EVENT Follow "[#1#] Follow #2#"
#EVENT Follow "<#1#> Follow #2#"
#EVENT Follow "#1# tells you, 'Follow #2#'"
#EVENT Follow "#1# tells the group, 'Follow #2#'"
#EVENT Follow "#1# tell your party, 'Follow #2#'"
SUB EVENT_Follow(line, ChatSender, eventParams)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_Follow ==>
  /if (${line.Find[,]}) /varset line ${line.Left[${Math.Calc[${line.Find[,]}-1]}]} ${line.Right[-${line.Find[,]}]}
  /if (!${checkEventArgs[${ChatSender},${line},UZ,${eventParams}]}) /return
  /declare SpawnToFollow string local ${c_eventArgData.Left[1].Upper}${c_eventArgData.Right[-1].Lower}
  /if (!${NetBots[${SpawnToFollow}].InZone} || ${SpawnToFollow.Equal[me]} || ${SpawnToFollow.Equal[on]}) /varset SpawnToFollow ${c_eventArgChatSender}
  | -Turn Following on and set the FollowTarget
  /varset FollowTarget ${Spawn[pc =${SpawnToFollow}].CleanName}
  | -If I am the follow target
  /if (${FollowTarget.Equal[${Me}]}) {
    /if (${Stick.Active}) /squelch /stick off
    /if (${NetAdvPath.Following}) /squelch /netfollow off
  } else {
    | -Check Range
    /if (${Spawn[=${FollowTarget}].Distance} > ${MaxResponseDist} && ${Bool[${NetBots[${SpawnToFollow}].InZone}]}) {
      /docommand ${ChatToggle} [${FollowTarget}] is too far away.
    } else {
      | -Check LoS.
      /if (!${Spawn[=${FollowTarget}].LineOfSight}) {
        /docommand ${ChatToggle} I cannot see [${FollowTarget}].
      } else {
        | -Stop assisting so we don't try to stick to the AssistTarget.
        /if (${Assisting} || ${Me.Combat}) /call AssistOff
          /varset Following TRUE
          /varset rebuffTimer 25
          /call AcquireFollow
      }
    }
  }
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_Follow -|
/RETURN

|----------------------------------------------------------------------------------------------------|
|- Engages follow plugins on specified follow targets.												-|
|----------------------------------------------------------------------------------------------------|
|- Uses NetAdvPath if the follow target is one of your bots, or MoveUtils, if its someone elses.	-|		
|----------------------------------------------------------------------------------------------------|
SUB AcquireFollow
/if (${Debug} || ${Debug_Basics}) /echo |- AcquireFollow ==>
		/if (${SpawnCount[=${FollowTarget} radius ${MaxResponseDist}]}) {
			/if (${FollowTarget.NotEqual[${Me.CleanName}]}) {
				/if (${Stick.Active}) /squelch /stick off
				/if (${NetAdvPath.Following}) /squelch /netfollow off

				/declare followTargetID int local
				/if (${SpawnCount[pc =${FollowTarget}]}) {
					/varset followTargetID ${Spawn[pc =${FollowTarget}].ID}
				} else /if (${SpawnCount[npc ${FollowTarget}]}) {
					/varset followTargetID ${Spawn[npc =${FollowTarget}].ID}
				} else /if (${SpawnCount[pet ${FollowTarget}]}) {
					/varset followTargetID ${Spawn[pet =${FollowTarget}].ID}
				}
				/if (${Bool[${Me.Casting.ID}]} && ${Me.Class.ShortName.NotEqual[BRD]}) /call interrupt
				 | If the FollowTarget is a NetBot, and you're using NetAdvPath
				/if (${NetBots[${FollowTarget}].ID} && ${NetAdvPath}) {
					/if (${Spawn[id ${followTargetID}].LineOfSight}) {
						/call TrueTarget ${followTargetID}
						/squelch /netfollow on
					}
				} else {
					/if (${Spawn[id ${followTargetID}].LineOfSight}) {
						/call TrueTarget ${followTargetID}
						/squelch /stick hold 20 uw
					}
				}
				/varset FollowCheckTimer 20+${Math.Calc[${Math.Rand[${NetBots.Counts}]}/2]}
			}
		}
/if (${Debug} || ${Debug_Basics}) /echo <== AcquireFollow -|
/RETURN

|----------------------------------------------------------------------------|
|- Disengages follow on bots who are in the same zone as the ChatSender.	  -|
|- Use, /stop, in  /group, or /bc.							                            -|
|----------------------------------------------------------------------------|
#bind StopFollowing /StopFollowing
SUB Bind_StopFollowing(yLoc,xLoc)
  /if (${Stick.Active} || ${NetAdvPath.Following} || ${Following}) {
    /if (${Stick.Active}) /squelch /stick off
    /if (${NetAdvPath.Following}) /squelch /netfollow off
    /call MoveToLoc ${yLoc} ${xLoc} 20 20
    /varset FollowTarget
    /varset Following FALSE
  }
/return

|----------------------------------------------------------------------------|
#EVENT Stop	"<#1#> Stop"
#EVENT Stop "#1# tells the group, 'Stop'"
#EVENT Stop "#1# you tell your party, 'Stop'"
SUB EVENT_Stop(line, ChatSender)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_Stop ==>
	/if (${Following}) {
    /if (${line.Find[,]}) /varset line ${line.Left[${Math.Calc[${line.Find[,]}-1]}]} ${line.Right[-${line.Find[,]}]}
    /if (!${checkEventArgs[${ChatSender},${line},UZR]}) /return
      | -Wait to get close to the followTarget.
    /delay 1s ${Spawn[${FollowTarget}].Distance} < 25
    | -Stop following
    /if (${Stick.Active}) /squelch /stick off
    /if (${NetAdvPath.Following}) /squelch /netfollow off
    /varset FollowTarget NULL
    /varset Following FALSE
  }
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_Stop -|
/RETURN STOP

|----------------------------------------------------------------------------|
#EVENT MoveHere "<#1#> Move to #2#"
#EVENT MoveHere "#1# tells you, 'Move to #2#'"
#EVENT MoveHere "#1# tells the group, 'Move to #2#'"
SUB EVENT_MoveHere(line, ChatSender, eventParams)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_MoveHere ==>
  /if (${line.Find[,]}) /varset line ${line.Left[${Math.Calc[${line.Find[,]}-1]}]} ${line.Right[-${line.Find[,]}]}
  /if (!${checkEventArgs[${ChatSender},${line},UZR,${eventParams}]}) /return
  /if (!${Int[${c_eventArgData}]}) /return
  |never move the person who issued the command
  /if (${c_eventArgChatSender.Equal[${Me}]}) /return
  /if (!${SpawnCount[id ${c_eventArgData}]}) /return
  |turn off following, assist
  /if (${Stick.Active})         /squelch /stick off
  /if (${NetAdvPath.Following}) /squelch /netfollow off
  /varset FollowTarget  NULL
  /varset Following     FALSE
  /if (${Assisting}  || ${Me.Combat}) /call AssistOff

  /call MoveToLoc ${Spawn[id ${c_eventArgData}].Loc} 50 15
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_MoveHere -|
/RETURN

|--------------------------------------------------------------------------------------|
|- Commands bots to bark a message at a target.															          -|
|- Targets can be designated by name, or ID, using -ID| or -Name|                     -|
|- @param line: '<Name> Bark at MobName BarkMsg'														          -|
|- @param msgTarget: The NPC you wish to bark at.														          -|
|- @param barkIt: What to bark at the NPC.																            -|
|- @param ChatSender: The command sender that requested bark.								          -|
|- @param selectedBots: Bots specified to bark at npc.											          -|
|- Use, '/bark MESSAGE', or 'Bark at NAME MESSAGE' can be given in /bc, /g, or /tell. -|
|--------------------------------------------------------------------------------------|
#EVENT bark "<#1#> Bark at #2# #3#"
#EVENT bark "#1# tells the group, 'Bark at #2# #3#'"
#EVENT bark "#1# tell your party, 'Bark at #2# #3#'"
SUB EVENT_bark(line, ChatSender, msgTarget, barkMsg)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_Bark ==>
  /if (${line.Find[,]}) /varset line ${line.Left[${Math.Calc[${line.Find[,]}-1]}]} ${line.Right[-${line.Find[,]}]}
  /if (!${checkEventArgs[${ChatSender},${line},UZR,${barkMsg}]}) /return
  | -If msgTarget is not an ID, find TargetID.
  /if (!${Int[${msgTarget}]}) {
    /if (${SpawnCount[npc =${msgTarget}]}) {
      /varset msgTarget ${Spawn[npc =${msgTarget}].ID}
    } else /if (${SpawnCount[pc =${msgTarget}]}) {
      /varset msgTarget ${Spawn[npc =${msgTarget}].ID}
    } else /if (${SpawnCount[pet =${msgTarget}]}) {
      /varset msgTarget ${Spawn[npc =${msgTarget}].ID}
    } else {
      /echo Could not find a SpawnID for [${msgTarget}].
      /varset msgTarget NULL
      /return
    }
  }
  /if (${c_eventArgChatSender.Equal[${Me}]}) /delay 2s
  /varset barkTarget ${Spawn[id ${msgTarget}].CleanName}
  /varset barkReturned FALSE

  /declare retryTimer timer local 15s
  /declare startingLoc string local

  /if (${Spawn[id ${msgTarget}].Distance}>${MaxResponseDist}) {
    /echo Bark Failed - ${Spawn[id ${msgTarget}].CleanName} is > ${MaxResponseDist} distance
    /return
  }

  /if (${Stick.Active}) /squelch /stick off
  /if (${NetAdvPath.Following}) /squelch /netfollow off
  /if (${Me.Casting.ID} && ${Me.Class.ShortName.NotEqual[BRD]}) /call interrupt

  /doevents barkReturn flush

  :retry_Bark
  /if (${Me.Invis}) /makemevisible
  /call TrueTarget ${msgTarget}
  /if (${Target.Distance} > 5) /call MoveToLoc ${Target.Y} ${Target.X} 50 5
  | -Wait a moment, then bark the message.
  /delay ${Math.Rand[8]}
  /varset startingLoc ${Me.Loc.Replace[ ,]}

  | -Reset barkMsg
  /if (${c_eventArgData.Find[-]} && ${c_eventArgData.Find[|]}) {
    /varset barkMsg ${c_eventArgData.Arg[1,-]}
    /varset barkMsg ${c_eventArgData.Left[${Math.Calc[${c_eventArgData.Length} - 1].Int}]}
  }

  /say ${barkMsg}
  | -Wait up to 2 seconds for something to happen.
  /delay 2s ${Zone.ID} != ${currentZone} || ${Me.Loc.Replace[ ,].NotEqual[${startingLoc}]} || ${Window[ConfirmationDialogBox].Open} || ${Window[LargeDialogWindow].Open}

  | -Click Yes to a confirmation box.
  /if (${Window[ConfirmationDialogBox].Open}) {
    /notify ConfirmationDialogBox Yes_Button leftmouseup
    /delay 1s
  } else /if (${Window[LargeDialogWindow].Open}) {
    /notify LargeDialogWindow LDW_YesButton leftmouseup
    /delay 1s
  }

  /doevents barkReturn
  | -Check to see if the bark was successful.
  /if (${Zone.ID} == ${currentZone} && ${Math.Distance[${startingLoc}]} < 8 && !${barkReturned}) {
    /if (${retryTimer}) {
      /goto :retry_Bark
    } else {
      /docommand ${ChatToggle} Nothing seems to have happened...
    }
  }
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_Bark -|
/RETURN

|------------------------------------------------------------|
|- Attempts to detected NPC responses to PC hails in /say.	-|
|- @param line: '|BarkTarget| says, 'Something''			      -|
|- @param returnBark: What the NPC replied.					        -|
|------------------------------------------------------------|
#EVENT barkReturn "${barkTarget} #1#"
SUB EVENT_barkReturn(line, returnBark)
	/varset barkReturned TRUE
/RETURN

|----------------------------------------------------------------------------|
|- Moves to a given location, and clicks the nearest object.				        -|
|----------------------------------------------------------------------------|
#EVENT clickIt "<#1#> Click It#2#"
#EVENT clickIt "#1# tells the group, 'Click It#2#'"
#EVENT clickIt "#1# tell your party, 'Click It#2#'"
SUB EVENT_clickIt(line, ChatSender, eventParams)
  /declare debug_clickit bool local FALSE
  /if (${line.Find[,]}) /varset line ${line.Left[${Math.Calc[${line.Find[,]}-1]}]} ${line.Right[-${line.Find[,]}]}
  /if (!${checkEventArgs[${ChatSender},${line},UZR,${eventParams}]}) /return
  /if (${c_eventArgChatSender.Equal[${Me}]}) /delay 2s
  /if (${Me.Casting.ID} && ${Me.Class.ShortName.NotEqual[BRD]}) /call interrupt
  /declare i int local
  /declare closestDoorID int local 0
  /declare closestDoorDist float local 0
  |load array of doors from doors.ini:  doorid, x, y, z, name
  /call IniToArrayV "e3 Macro Inis\doors.ini,${Zone.ShortName},${Zone.ShortName}#" doorList
  /if (!${Defined[doorList]}) {
    /if (${Me.CleanName.Equal[Creamo]}) /bc I have no doorList for this zone
  } else {
    /if (${debug_clickit}) /echo Doors in zone ${doorList.Size}
    |find the closest door to me
    /for i 1 to ${doorList.Size}
      /if (${debug_clickit}) /echo ${i} ${doorList[${i}]}
      /squelch /doortarget id ${doorList[${i}].Arg[1,,]}
      /if ((${closestDoorDist}==0 || ${DoorTarget.Distance} < ${closestDoorDist}) && ${DoorTarget.DistanceZ} < 125 && ${DoorTarget.Distance} < 400) {
        /varset closestDoorDist ${DoorTarget.Distance}
        /varset closestDoorID ${doorList[${i}].Arg[1,,]}
      }
    /next i
  }
  | if i have a door within 100 distance then move to it and try to click
  /if (${debug_clickit}) /echo closest ${closestDoorID} ${closestDoorDist}
  /if (!${Bool[${closestDoorID}]}) {
    /squelch /doortarget
    /if (${DoorTarget.Distance} < ${MaxResponseDist}) {
      /varset closestDoorID ${Switch.ID}
      /if (${debug_clickit}) /echo no door in file, picked closest door ${Switch.ID}
    } else {
      /echo \ay Aborting ClickIt: I could not find an acceptable door < ${MaxResponseDist} units
      /return
    }
  }
  /squelch /doortarget id ${closestDoorID}
  /if (${DoorTarget.Distance} > 20) /call MoveToLoc ${DoorTarget.Y} ${DoorTarget.X} 50 15
  /if (${DoorTarget.Distance} > 35) {
    /echo \ay Aborting ClickIt: I could not moveto < 20 units of ${DoorTarget.Name} within 5s
    /moveto off
    /return
  } else {
    /declare MyZone int local ${Zone.ID}
    /declare clickTimer timer local 5s
    |add starting loc vs final loc for intrazone click
    /declare clickDelay int local ${Math.Calc[${Math.Rand[${Me.ID}]}%${clickitRandomDelay}|1]}
    /declare startingLoc ${Me.Loc}
    :retryClickDoor
    /delay ${clickDelay}
    /squelch /doortarget id ${closestDoorID}
    
    |casting while zoning has been reported to cause a problem
    | If casting, dismount if mounted and call /stopcast
    /if (${Cast.Status.Find[C]} || ${Me.Casting.ID}) {
      /if (${NetBots[${Me.Name}].Mounted}) /dismount
      /stopcast
    }
    /squelch /click left door
    /if (${MyZone}==${Zone.ID} && ${Math.Distance[${startingLoc}]} < 10) {
      /if (${clickTimer}) {
        /goto :retryClickDoor
      } else {
        /echo \ay I have failed to click Door ${Switch.ID} ${DoorTarget.Name}
        /moveto off
        /return
      }
    }
  }
/RETURN

|--------------------------------------------------------------------------|
|- Moves to a given location, and clicks the nearest object.				      -|
|- This is only here to support a situation wheres doors.txt lacks a door -|
|- @param ChatSender: The command sender.									                -|
|- @param locToStart: Where to stand when attempting to click the object.	-|
|--------------------------------------------------------------------------|
#EVENT oldclickIt "<#1#> OldClickIt #2#"
#EVENT oldclickIt "#1# tells the group, 'OldClickIt #2#'"
#EVENT oldclickIt "#1# tell your party, 'OldClickIt #2#'"
SUB EVENT_oldclickIt(line, ChatSender, locToStart)
  /if (${Debug} || ${Debug_Basics}) /echo |- EVENT_clickIt ==>
  /if (${line.Find[,]}) /varset line ${line.Left[${Math.Calc[${line.Find[,]}-1]}]} ${line.Right[-${line.Find[,]}]}
  /if (!${checkEventArgs[${ChatSender},${line},UZR,${locToStart}]}) /return
  | -Check LoS.
  /if (!${LineOfSight[${Me.Loc.Replace[ ,]}:${c_eventArgData}]}) {
    /docommand ${ChatToggle} I cannot see the object to click.
  } else {
    /if (${locToStart.Find[ ]}) /varset locToStart ${locToStart.Arg[1, ]}
    | -Check range to object.
    /if (${Math.Distance[${locToStart}]} > ${Math.Calc[${MaxResponseDist}*3].Int}) {
      /docommand ${ChatToggle} That object is too far away to click.
    } else {
      /declare retryTimer timer local 15s
      /declare miscTimer timer local
      /declare startZone int local ${Zone.ID}
      /if (${Stick.Active}) /squelch /stick off
      /if (${NetAdvPath.Following}) /squelch /netfollow off
      /if (${Me.Casting.ID} && ${Me.Class.ShortName.NotEqual[BRD]}) /call interrupt
      :retryClick
      /if (${Math.Distance[${locToStart}]} > 10) /call MoveToLoc ${locToStart} 30 20
      /if (${Math.Distance[${locToStart}]} > 10) {
        /docommand ${ChatToggle} I failed to move to the inteded object
      } else {
        | -Switch to first person camera.
        /keypress First_Person_Camera
        | -Face object and attempt to click it for up to 5 seconds.
        /varset miscTimer 50
        /squelch /doortarget
        /squelch /face fast door
        /squelch /look -75
        :keypress
        | -Shifts look angle up and down while attempting to click.
        /look ${If[${Me.Look} < 120,${Math.Calc[${Me.Look} + 5]},-75]}
        /if (${Target.ID}) /squelch /target clear
        /keypress U
        /delay 2
        | -Check if I have zoned, or moved.
        /if (${Zone.ID} == ${currentZone} && ${Math.Distance[${locToStart}]} < 50) {
          | -Check keypressTimer.
          /if (${miscTimer}) {
            /goto :keypress
          } else {
            | -Check the retryTimer.
            /if (${retryTimer}) {
              /if (${Debug} || ${Debug_Basics}) /echo |- EVENT_clickIt -| Click attempt failed, retrying.
              /keypress back hold
              /delay 2
              /keypress forward
              /delay ${Math.Rand[30]}
              /if (${retryTimer}) /goto :retryClick
              | -If the retryTimer has expired, and I have not clicked the object.
            } else {
              /docommand ${ChatToggle} I have failed to click the object.
            }
          }
        }
      }
    }
  }
  /if (${Debug} || ${Debug_Basics}) /echo <== EVENT_clickIt -|
/RETURN

|----------------------------------------------------------------------------|
|- Points faces bots to your current heading, and runs through a zone line.	-|
|- @param ChatSender: The command sender.									                  -|
|- @param locToStart: Where to stand when trying to click the door.			    -|
|- @param snapHeading: The direction to face when trying to click the door.	-|
|----------------------------------------------------------------------------|
#EVENT runThruZone "<#1#> Run through zone#2#"
#EVENT runThruZone "#1# tells the group, 'Run through zone#2#'"
#EVENT runThruZone "#1# tell your party, 'Run through zone#2#'"
SUB EVENT_runThruZone(line, ChatSender, eventParams)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_runThruZone ==>
  /if (${line.Find[,]}) /varset line ${line.Left[${Math.Calc[${line.Find[,]}-1]}]} ${line.Right[-${line.Find[,]}]}
  /if (!${checkEventArgs[${ChatSender},${line},UZR,${eventParams}]}) /return
  /if (${c_eventArgChatSender.Equal[${Me}]}) /delay 2s
  /declare locToStart string local ${Spawn[pc ${c_eventArgChatSender}].Loc}
  /declare startHeading float local ${Spawn[pc ${c_eventArgChatSender}].Heading.Degrees}
  /declare retryTimer timer local 7s
  /declare miscTimer timer local
  /declare startZone int local ${Zone.ID}
  | -Check that you can see the location to start from.
  /if (!${LineOfSight[${Me.Loc.Replace[ ,]}:${locToStart}]}) {
    /docommand ${ChatToggle} I cannot see the starting location.
  } else {
    | -Check range to object.
    /if (${Math.Distance[${locToStart}]} > ${Math.Calc[${MaxResponseDist}*3].Int}) {
      /docommand ${ChatToggle} I am to far away from that zone line.
    } else {
      /if (${Stick.Active}) /squelch /stick off
      /if (${NetAdvPath.Following}) /squelch /netfollow off
      /if (${Me.Casting.ID} && ${Me.Class.ShortName.NotEqual[BRD]}) /delay 5s !${Me.Casting.ID}
    :retryRTZ
      | -Check if I need to move closer.
      /if (${Math.Distance[${locToStart}]} > 10) /call MoveToLoc ${locToStart} 50
      | -Face the zone and run foward for 6 seconds.
      /face fast heading ${Math.Calc[${startHeading}*-1]}
      /delay 2
      /keypress forward hold
      | -Wait to zone.
      /delay 6s !${Zone.ID} || ${Zone.ID} != ${startZone}
      | -Check if I zoned.
      /if (${Zone.ID} == ${startZone}) {
        /if (${retryTimer}) {
          /goto :retryRTZ
        } else {
          /docommand ${ChatToggle} I failed to run through the zoneline in [${Zone}].
          /call MoveToLoc ${locToStart} 30 20
        }
      }
    }
  }
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_runThruZone -|
/RETURN

|----------------------------------------|
#EVENT dropInvis "<#1#> Drop Invis#*#"
SUB EVENT_dropInvis(line, ChatSender)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_dropInvis ==>
  /if (!${checkEventArgs[${ChatSender},${line},UZR]}) /return
  /if (${Me.Invis}) /makemevisible
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_dropInvis -|
/RETURN

|----------------------------------------|
#EVENT dropBuff "<#1#> Drop Buff #2#"
SUB EVENT_dropBuff(line, ChatSender, buffName)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_dropInvis ==>
  /if (!${checkEventArgs[${ChatSender},${line},UZR,${buffName}]}) /return
  /if (${c_eventArgData.Equal[All]}) {
    /declare i int local 1
    /for i 1 to 25
      /if (${Me.Buff[${i}].ID}) {
        /squelch /removebuff ${Me.Buff[${i}].Name}
        /delay 1
      }
    /next i
  } else {
    /removebuff ${c_eventArgData}
  }
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_dropInvis -|
/RETURN

|----------------------------------------------------|
|- Uses /exit on all bots, except the ChatSender.	  -|
|- Use, /bc Exit		                                -|
|----------------------------------------------------|
#EVENT Exit "<#1#> Exit#*#"
SUB EVENT_Exit(line, ChatSender)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_Exit ==>
  /if (!${checkEventArgs[${ChatSender},${line},U]}) /return
  /docommand ${ChatToggle} Bye!
  /if (${Spawn[${ChatSender}].ID}!=${Me.ID}) /exit
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_Exit -|
/RETURN

|------------------------------------------------------------|
|- Attempts to load the spellset listed in e3_Settings.ini.	-|
|------------------------------------------------------------|
#EVENT LoadSpells "<#1#> Load Spells"
SUB EVENT_LoadSpells(line, ChatSender)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_LoadSpells ==>
  /if (!${checkEventArgs[${ChatSender},${line},U]}) /return
  /if (${Me.Class.CanCast} && ${Defined[Default_SpellSet]}) {
    /declare spellsetMem_Timer timer local 300
    /docommand ${ChatToggle} Loading spells...
    /memspellset ${Default_SpellSet}
    :Memloop
    /if (${Debug} || ${Debug_Basics}) /echo |- EVENT_LoadSpells -| :Memloop

    /call Background_Events
    /if (${Debug} || ${Debug_Basics}) /echo spellsetMem_Timer = [${spellsetMem_Timer}]
    /if (${Window[SpellBookWnd].Open} && ${spellsetMem_Timer}) /goto :Memloop
    /if (${Me.Sitting}) /stand
  }
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_LoadSpells -|
/RETURN

|--------------------------------------------------------|
|- Checks for specified buffs and debuffs on NetBots.		-|
|- Use, /bc Check buff Name.	                          -|
|--------------------------------------------------------|
#EVENT CheckBuffs "<#1#> Check buff #2#"
SUB EVENT_CheckBuffs(line, ChatSender, eventParams)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_CheckBuffs ==>
  /if (!${checkEventArgs[${ChatSender},${line},UZ,${eventParams}]}) /return
  /if (${Bool[${Me.Buff[${c_eventArgData}]}]}) {
      /docommand ${ChatToggle} ${Me.Buff[${c_eventArgData}].Duration.TotalSeconds} seconds left on [${c_eventArgData}].
  }
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_CheckBuffs -|
/RETURN

|--------------------------------------------------------|
|- Searches inventory, and banks, for indicated items.	-|
|- Use, /bc Find 'Name', /echo Find 'Name'.			        -|
|- Accepts item links as 'Name'                         -|
|--------------------------------------------------------|
#EVENT FindItems "<#1#> Find Item #2#"
SUB EVENT_FindItems(line, ChatSender, ItemToFind)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_FindItems ==>
  /if (!${checkEventArgs[${ChatSender},${line},U,${ItemToFind}]}) /return
  /declare reportDelay int local 30
  |parse item link
  /if (${c_eventArgData.Find[000]}) {
    /varset ItemToFind ${c_eventArgData.Right[${Math.Calc[${c_eventArgData.Length} - 57]}].Left[-1]}
  } else {
    /varset ItemToFind ${c_eventArgData}
  }
  /declare i int local
  /declare e int local
  /declare a int local
  /declare totalItems int local 0
  | -Check cursor.
  /if (${Cursor.Name.Equal[${ItemToFind}]}) {
    /varcalc totalItems ${totalItems}+${Cursor.Stack}
    /docommand /timed ${reportDelay} ${ChatToggle} >>> Found ${Cursor.Name}(${Cursor.Stack})-> [Cursor] <<<
  }
  /if (${FindItemCount[${ItemToFind}]}) {
    | -Search Equippped Items.
    /for i 1 to 22
      /if (${InvSlot[${i}].Item.Name.Find[${ItemToFind}]}) {
        /varcalc totalItems ${totalItems}+${InvSlot[${i}].Item.Stack}
        /docommand /timed ${reportDelay} ${ChatToggle} ${InvSlot[${i}].Item}(${InvSlot[${i}].Item.Stack})-> [${InvSlot[${i}].Name}]
      }
      /for a 0 to ${InvSlot[${i}].Item.Augs}
        /if (${InvSlot[${i}].Item.AugSlot[${a}].Name.Find[${ItemToFind}]}) {
          /varcalc totalItems ${totalItems}+1
          /docommand /timed ${reportDelay} ${ChatToggle} ${InvSlot[${i}].Item.AugSlot[${a}]}-> [${InvSlot[${i}].Item}-> ${InvSlot[${i}].Name}]
        }
      /next a
    /next i
    | -Search packslots.
    /for i 1 to ${numInventorySlots}
      /if (${Me.Inventory[pack${i}].Name.Find[${ItemToFind}]}) {
        /varcalc totalItems ${totalItems}+${Me.Inventory[pack${i}].Stack}
        /docommand /timed ${reportDelay} ${ChatToggle} ${Me.Inventory[pack${i}]}(${Me.Inventory[pack${i}].Stack})-> InvSlot${i}]
      }
      /if (${Me.Inventory[pack${i}].Container}) {
        /for e 1 to ${Me.Inventory[pack${i}].Container}
          /if (${Me.Inventory[pack${i}].Item[${e}].Name.Find[${ItemToFind}]}) {
            /varcalc totalItems ${totalItems}+${Me.Inventory[pack${i}].Item[${e}].Stack}
            /docommand /timed ${reportDelay} ${ChatToggle} ${Me.Inventory[pack${i}].Item[${e}]}(${Me.Inventory[pack${i}].Item[${e}].Stack})-> [${Me.Inventory[pack${i}]}-> InvSlot${i}-> PackSlot${e}]
          }
          /for a 0 to ${Me.Inventory[pack${i}].Item[${e}].Augs}
            /if (${Me.Inventory[pack${i}].Item[${e}].AugSlot[${a}].Name.Find[${ItemToFind}]}) {
              /varcalc totalItems ${totalItems}+1
              /docommand /timed ${reportDelay} ${ChatToggle} ${Me.Inventory[pack${i}].Item[${e}].AugSlot[${a}]}-> [${Me.Inventory[pack${i}].Item[${e}]}]-> [${Me.Inventory[pack${i}]}-> InvSlot${i}-> PackSlot${e}]
            }
          /next a
        /next e
      }
    /next i
  }
  | -Search bank packslots.
    /for i 1 to 26
      /if (${Me.Bank[${i}].Name.Find[${ItemToFind}]}) {
        /varcalc totalItems ${totalItems}+${Me.Bank[${i}].Stack}
        /docommand /timed ${reportDelay} ${ChatToggle} ${Me.Bank[${i}]}(${Me.Bank[${i}].Stack}) ->[BankSlot${i}]
      }
      /if (${Me.Bank[${i}].Container}) {
        /for e 1 to ${Me.Bank[${i}].Container}
          /if (${Me.Bank[${i}].Item[${e}].Name.Find[${ItemToFind}]}) {
            /varcalc totalItems ${totalItems}+${Me.Bank[${i}].Item[${e}].Stack}
            /docommand /timed ${reportDelay} ${ChatToggle} ${Me.Bank[${i}].Item[${e}]}(${Me.Bank[${i}].Item[${e}].Stack})-> [${Me.Bank[${i}]}-> BankSlot${i}-> PackSlot${e}]
          }
          /for a 0 to ${Me.Bank[${i}].Item[${e}].Augs}
            /if (${Me.Bank[${i}].Item[${e}].AugSlot[${a}].Name.Find[${ItemToFind}]}) {
              /varcalc totalItems ${totalItems}+1
              /docommand /timed ${reportDelay} ${ChatToggle} ${Me.Bank[${i}].Item[${e}].AugSlot[${a}]}-> [${Me.Bank[${i}].Item[${e}]}]-> ${Me.Bank[${i}]}-> BankSlot${i}-> PackSlot${e}
            }
          /next a
        /next e
      }
    /next i
  /if (${totalItems} > 0) /docommand ${ChatToggle} >> Found (${totalItems}) : [${ItemToFind}] <<

/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_FindItems -|
/RETURN
|--------------------------------------------------------|
#EVENT FindItemCompact "<#1#> Find ItemC #2#"
SUB EVENT_FindItemCompact(line, ChatSender, ItemToFind)
  /if (${Debug} || ${Debug_Basics}) /echo |- EVENT_FindItems ==>
  /if (!${checkEventArgs[${ChatSender},${line},U,${ItemToFind}]}) /return
  /declare reportDelay int local 1
  /declare reportArray[50] string local NIL
  /declare raINDX int local 1
|parse item link
  /if (${c_eventArgData.Find[000]}) {
    /varset ItemToFind ${c_eventArgData.Right[${Math.Calc[${c_eventArgData.Length} - 57]}].Left[-1]}
  } else {
    /varset ItemToFind ${c_eventArgData}
  }
  /declare i int local
  /declare e int local
  /declare a int local
  /declare r int local
  /declare totalItems int local 0
| -Check cursor.
  /if (${Cursor.Name.Equal[${ItemToFind}]}) {
    /varcalc totalItems ${totalItems}+${Cursor.Stack}
    /varset reportArray[${raINDX}] [Cursor]${Cursor.Name}(${Cursor.Stack}
    /varcalc raINDX ${raINDX}+1
    |/docommand /timed ${reportDelay} ${ChatToggle} >>> Found ${Cursor.Name}(${Cursor.Stack})-> [Cursor] <<<
  }
  /if (${FindItemCount[${ItemToFind}]}) {
    | -Search Equippped Items.
    /for i 1 to 22
      /if (${InvSlot[${i}].Item.Name.Find[${ItemToFind}]}) {
        /varcalc totalItems ${totalItems}+${InvSlot[${i}].Item.Stack}
        /varset reportArray[${raINDX}] [Worn]${InvSlot[${i}].Item}(${InvSlot[${i}].Item.Stack}
        |/echo ${raINDX} ${reportArray[${raINDX}]} ${InvSlot[${i}].Item}
        /varcalc raINDX ${raINDX}+1
        |/docommand /timed ${reportDelay} ${ChatToggle} ${InvSlot[${i}].Item}(${InvSlot[${i}].Item.Stack})-> [${InvSlot[${i}].Name}]
      }
      /for a 0 to ${InvSlot[${i}].Item.Augs}
        /if (${InvSlot[${i}].Item.AugSlot[${a}].Name.Find[${ItemToFind}]}) {
          /varcalc totalItems ${totalItems}+1
          /varset reportArray[${raINDX}] [Worn]${InvSlot[${i}].Item.AugSlot[${a}]}(1
          /varcalc raINDX ${raINDX}+1
          |/docommand /timed ${reportDelay} ${ChatToggle} ${InvSlot[${i}].Item.AugSlot[${a}]}-> [${InvSlot[${i}].Item}-> ${InvSlot[${i}].Name}]
        }
      /next a
    /next i
    | -Search packslots.
    |/echo p${raINDX}
    /for i 1 to ${numInventorySlots}
    /if (${Me.Inventory[pack${i}].Name.Find[${ItemToFind}]}) {
      /varcalc totalItems ${totalItems}+${Me.Inventory[pack${i}].Stack}
      /varset reportArray[${raINDX}] [Pack]${Me.Inventory[pack${i}]}(${Me.Inventory[pack${i}].Stack}
      |/echo [Pack]${Me.Inventory[pack${i}]}
      /varcalc raINDX ${raINDX}+1
      |/docommand /timed ${reportDelay} ${ChatToggle} ${Me.Inventory[pack${i}]}(${Me.Inventory[pack${i}].Stack})-> InvSlot${i}]
    }
    /if (${Me.Inventory[pack${i}].Container}) {
      /for e 1 to ${Me.Inventory[pack${i}].Container}
        /if (${Me.Inventory[pack${i}].Item[${e}].Name.Find[${ItemToFind}]}) {
          /varcalc totalItems ${totalItems}+${Me.Inventory[pack${i}].Item[${e}].Stack}
          /varset reportArray[${raINDX}] [Bag]${Me.Inventory[pack${i}].Item[${e}]}(${Me.Inventory[pack${i}].Item[${e}].Stack}
          |/echo [Bag]${Me.Inventory[pack${i}].Item[${e}]}
          /varcalc raINDX ${raINDX}+1
          |/docommand /timed ${reportDelay} ${ChatToggle} ${Me.Inventory[pack${i}].Item[${e}]}(${Me.Inventory[pack${i}].Item[${e}].Stack})-> [${Me.Inventory[pack${i}]}-> InvSlot${i}-> PackSlot${e}]
        }
        /for a 0 to ${Me.Inventory[pack${i}].Item[${e}].Augs}
        /if (${Me.Inventory[pack${i}].Item[${e}].AugSlot[${a}].Name.Find[${ItemToFind}]}) {
          /varcalc totalItems ${totalItems}+1
          /varset reportArray[${raINDX}] [Bag]${Me.Inventory[pack${i}].Item[${e}].AugSlot[${a}]}(1
          |/echo [Bagaug]${Me.Inventory[pack${i}].Item[${e}].AugSlot[${a}]}
          /varcalc raINDX ${raINDX}+1
          |/docommand /timed ${reportDelay} ${ChatToggle} ${Me.Inventory[pack${i}].Item[${e}].AugSlot[${a}]}-> [${Me.Inventory[pack${i}].Item[${e}]}]-> [${Me.Inventory[pack${i}]}-> InvSlot${i}-> PackSlot${e}]
        }
        /next a
      /next e
    }
    /next i
  }
| -Search bank packslots.
  |/echo b${raINDX}
  /for i 1 to 26
  /if (${Me.Bank[${i}].Name.Find[${ItemToFind}]}) {
    /varcalc totalItems ${totalItems}+${Me.Bank[${i}].Stack}
    /varset reportArray[${raINDX}] [Bank]${Me.Bank[${i}]}(${Me.Bank[${i}].Stack}
    /varcalc raINDX ${raINDX}+1
    |/docommand /timed ${reportDelay} ${ChatToggle} ${Me.Bank[${i}]}(${Me.Bank[${i}].Stack}) ->[BankSlot${i}]
  }
  /if (${Me.Bank[${i}].Container}) {
    /for e 1 to ${Me.Bank[${i}].Container}
    /if (${Me.Bank[${i}].Item[${e}].Name.Find[${ItemToFind}]}) {
      /varcalc totalItems ${totalItems}+${Me.Bank[${i}].Item[${e}].Stack}
      /varset reportArray[${raINDX}] [Bank]${Me.Bank[${i}].Item[${e}]}(${Me.Bank[${i}].Item[${e}].Stack}
      /varcalc raINDX ${raINDX}+1
      |/docommand /timed ${reportDelay} ${ChatToggle} ${Me.Bank[${i}].Item[${e}]}(${Me.Bank[${i}].Item[${e}].Stack})-> [${Me.Bank[${i}]}-> BankSlot${i}-> PackSlot${e}]
    }
    /for a 0 to ${Me.Bank[${i}].Item[${e}].Augs}
    /if (${Me.Bank[${i}].Item[${e}].AugSlot[${a}].Name.Find[${ItemToFind}]}) {
      /varcalc totalItems ${totalItems}+1
      /varset reportArray[${raINDX}] [Bag]${Me.Bank[${i}].Item[${e}].AugSlot[${a}]}(1
      /varcalc raINDX ${raINDX}+1
      |/docommand /timed ${reportDelay} ${ChatToggle} ${Me.Bank[${i}].Item[${e}].AugSlot[${a}]}-> [${Me.Bank[${i}].Item[${e}]}]-> ${Me.Bank[${i}]}-> BankSlot${i}-> PackSlot${e}
    }
    /next a
    /next e
  }
  /next i

  |/echo ${raINDX} ${reportArray[1]}
  /for r 1 to ${raINDX}
    /if (${reportArray[${r}].NotEqual[NIL]}) /docommand ${ChatToggle} ${reportArray[${r}]}/${totalItems})
  /next r
  |/if (${totalItems} > 0) /docommand ${ChatToggle} >> Found (${totalItems}) : [${ItemToFind}] <<

  /if (${Debug} || ${Debug_Basics}) /echo <== EVENT_FindItems -|
/RETURN
|--------------------------------------------------------|
|- Finditem with no summary data for easier viewing
|--------------------------------------------------------|
SUB FindItemSub(ItemToFind,reportTotal,reportDelay)
  /declare i int local
  /declare e int local
  /declare a int local
  /declare totalItems int local 0
  | -Check cursor.
  /if (${Cursor.Name.Equal[${ItemToFind}]}) {
    /varcalc totalItems ${totalItems}+${Cursor.Stack}
    /docommand /timed ${reportDelay} ${ChatToggle} >>> Found ${Cursor.Name}(${Cursor.Stack})-> [Cursor] <<<
  }
  /if (${FindItemCount[${ItemToFind}]}) {
    | -Search Equippped Items.
    /for i 1 to 22
    /if (${InvSlot[${i}].Item.Name.Find[${ItemToFind}]}) {
      /varcalc totalItems ${totalItems}+${InvSlot[${i}].Item.Stack}
      /docommand /timed ${reportDelay} ${ChatToggle} ${InvSlot[${i}].Item}(${InvSlot[${i}].Item.Stack})-> [${InvSlot[${i}].Name}]
    }
    /for a 0 to ${InvSlot[${i}].Item.Augs}
    /if (${InvSlot[${i}].Item.AugSlot[${a}].Name.Find[${ItemToFind}]}) {
      /varcalc totalItems ${totalItems}+1
      /docommand /timed ${reportDelay} ${ChatToggle} ${InvSlot[${i}].Item.AugSlot[${a}]}-> [${InvSlot[${i}].Item}-> ${InvSlot[${i}].Name}]
    }
    /next a
    /next i
    | -Search packslots.
    /for i 1 to ${numInventorySlots}
    /if (${Me.Inventory[pack${i}].Name.Find[${ItemToFind}]}) {
      /varcalc totalItems ${totalItems}+${Me.Inventory[pack${i}].Stack}
      /docommand /timed ${reportDelay} ${ChatToggle} ${Me.Inventory[pack${i}]}(${Me.Inventory[pack${i}].Stack})-> InvSlot${i}]
    }
    /if (${Me.Inventory[pack${i}].Container}) {
      /for e 1 to ${Me.Inventory[pack${i}].Container}
      /if (${Me.Inventory[pack${i}].Item[${e}].Name.Find[${ItemToFind}]}) {
        /varcalc totalItems ${totalItems}+${Me.Inventory[pack${i}].Item[${e}].Stack}
        /docommand /timed ${reportDelay} ${ChatToggle} ${Me.Inventory[pack${i}].Item[${e}]}(${Me.Inventory[pack${i}].Item[${e}].Stack})-> [${Me.Inventory[pack${i}]}-> InvSlot${i}-> PackSlot${e}]
      }
      /for a 0 to ${Me.Inventory[pack${i}].Item[${e}].Augs}
      /if (${Me.Inventory[pack${i}].Item[${e}].AugSlot[${a}].Name.Find[${ItemToFind}]}) {
        /varcalc totalItems ${totalItems}+1
        /docommand /timed ${reportDelay} ${ChatToggle} ${Me.Inventory[pack${i}].Item[${e}].AugSlot[${a}]}-> [${Me.Inventory[pack${i}].Item[${e}]}]-> [${Me.Inventory[pack${i}]}-> InvSlot${i}-> PackSlot${e}]
      }
      /next a
      /next e
    }
    /next i
  }
  | -Search bank packslots.
  /for i 1 to 26
  /if (${Me.Bank[${i}].Name.Find[${ItemToFind}]}) {
    /varcalc totalItems ${totalItems}+${Me.Bank[${i}].Stack}
    /docommand /timed ${reportDelay} ${ChatToggle} ${Me.Bank[${i}]}(${Me.Bank[${i}].Stack}) ->[BankSlot${i}]
  }
  /if (${Me.Bank[${i}].Container}) {
    /for e 1 to ${Me.Bank[${i}].Container}
    /if (${Me.Bank[${i}].Item[${e}].Name.Find[${ItemToFind}]}) {
      /varcalc totalItems ${totalItems}+${Me.Bank[${i}].Item[${e}].Stack}
      /docommand /timed ${reportDelay} ${ChatToggle} ${Me.Bank[${i}].Item[${e}]}(${Me.Bank[${i}].Item[${e}].Stack})-> [${Me.Bank[${i}]}-> BankSlot${i}-> PackSlot${e}]
    }
    /for a 0 to ${Me.Bank[${i}].Item[${e}].Augs}
    /if (${Me.Bank[${i}].Item[${e}].AugSlot[${a}].Name.Find[${ItemToFind}]}) {
      /varcalc totalItems ${totalItems}+1
      /docommand /timed ${reportDelay} ${ChatToggle} ${Me.Bank[${i}].Item[${e}].AugSlot[${a}]}-> [${Me.Bank[${i}].Item[${e}]}]-> ${Me.Bank[${i}]}-> BankSlot${i}-> PackSlot${e}
    }
    /next a
    /next e
  }
  /next i
  /if (${Bool[${reportTotal}]} && ${totalItems} > 0) /docommand ${ChatToggle} >> Found (${totalItems}) : [${ItemToFind}] <<
/RETURN
|------------------------------------------------------------------|
|- Reports which character lacks a specified item                 -|
|- 'Name' must be the full itemname, accepts item links as 'Name' -|
|- Use, /bc FindMissingItem 'Name', /echo FindMissingItem 'Name'	-|
|------------------------------------------------------------------|
#EVENT FindMissingItem "<#1#> Find Missing Item #2#"
SUB EVENT_FindMissingItem(line, ChatSender, ItemToFind)
  /if (!${checkEventArgs[${ChatSender},${line},U,${ItemToFind}]}) /return
  |parse item link
  /if (${c_eventArgData.Find[000]}) {
    /varset ItemToFind ${c_eventArgData.Right[${Math.Calc[${c_eventArgData.Length} - 57]}].Left[-1]}
  } else {
    /varset ItemToFind ${c_eventArgData}
  }
  /declare i int local
  /declare e int local
  /declare a int local
  /declare totalItems int local ${FindItemCount[=${ItemToFind}]}
  /varcalc totalItems ${totalItems}+${Cursor.Name.Equal[=${ItemToFind}]}

  /for i 1 to 26
    /if (${Me.Bank[${i}].Name.Equal[${ItemToFind}]}) {
      /varcalc totalItems ${totalItems}+1
    }
    /if (${Me.Bank[${i}].Container}) {
      /for e 1 to ${Me.Bank[${i}].Container}
        /if (${Me.Bank[${i}].Item[${e}].Name.Equal[${ItemToFind}]}) {
          /varcalc totalItems ${totalItems}+1
        }
        /for a 0 to ${Me.Bank[${i}].Item[${e}].Augs}
          /if (${Me.Bank[${i}].Item[${e}].AugSlot[${a}].Name.Equal[${ItemToFind}]}) {
            /varcalc totalItems ${totalItems}+1
          }
        /next a
      /next e
    }
  /next i

  /if (${totalItems}==0) /docommand ${ChatToggle} >> I did not find ${ItemToFind} <<
/RETURN

|------------------------------------------------------------|
|**
SUB LPAD_NAME_BC(myName, textToPad)
  /declare i int local
  /declare maxLength int local 0
  /declare numToPad int local
  /declare paddedText string local
  /for i 1 to ${NetBots.Counts}
    /if(${NetBots.Client[${i}].Length} > ${maxLength}) /varset maxLength ${NetBots.Client[${i}].Length}
  /next i

  /varcalc numToPad ${maxLength}-${Me.Nam.Length}
  /for i 1 to ${numToPad}
    /varset paddedText _${paddedText}
    /echo ${paddedText}
  /next i
/RETURN ${paddedText}
**|
|------------------------------------------------------------|
#EVENT FindSlot "<#1#> Find Slot #2#"
SUB EVENT_FindSlot(line, ChatSender, SlotToFind)
  /if (!${checkEventArgs[${ChatSender},${line},U,${SlotToFind}]}) /return
  /if (${Select[${c_eventArgData},charm,leftear,head,face,rightear,neck,shoulder,arms,back,leftwrist,rightwrist,ranged,hands,mainhand,offhand,leftfinger,rightfinger,chest,legs,feet,waist,powersource,ammo, fingers, wrists, ears]}) {

     /if (${c_eventArgData.Equal[fingers]}) {
        /gu Fingers --- left: ${InvSlot[leftfinger].Item.ItemLink} right : ${InvSlot[rightfinger].Item.ItemLink}
     } else /if (${c_eventArgData.Equal[wrists]}) {
        /gu Wrists --- left: ${InvSlot[leftwrist].Item.ItemLink} right : ${InvSlot[rightwrist].Item.ItemLink}
     } else /if (${c_eventArgData.Equal[ears]}) {
        /gu Ears --- left: ${InvSlot[leftear].Item.ItemLink} right: ${InvSlot[rightear].Item.ItemLink}
     } else /if (!${InvSlot[${c_eventArgData}].Item.ID}) {
        /gu ${c_eventArgData}: No Item Equipped
     } else {
        /gu ${c_eventArgData}: ${InvSlot[${c_eventArgData}].Item.ItemLink}
     }

  } else {
    /if (${c_eventArgChatSender.Equal[${Me}]}) {
      /echo Valid Slots: charm, leftear, head, face, rightear, neck, shoulder, arms, leftwrist, rightwrist, ranged, hands, mainhand, offhand, ammo, back, leftfinger, rightfinger, chest, legs, feet, waist, powersource, fingers, wrists, ears
    }
  }
/RETURN
|------------------------------------------------------------|
|- Checks for bots who are out of range, or out of zone.	  -|
|- Use, /count, or, /bc Count bots							            -|
|------------------------------------------------------------|
#EVENT CountBots "[#*#] Head Count"
SUB EVENT_CountBots
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_CountBots ==>
	/if (!${NetBots.Counts}) {
		/echo You must be connected to MQ2EQBC, and, MQ2NetBots, to use this function.
	} else {
		/declare i int local
		/declare InRangeCount int local
		/declare OutOfRange string local
		/declare OutOfRangeCount int local
		/declare OutOfZone string local
		/declare OutOfZoneCount int local
		
		/for i 1 to ${NetBots.Counts}
			/if (!${SpawnCount[pc ${NetBots.Client[${i}]}]}) {
				/varset OutOfZone ${OutOfZone}${NetBots.Client[${i}]},
				/varcalc OutOfZoneCount ${OutOfZoneCount} + 1
			} else /if (${SpawnCount[pc ${NetBots.Client[${i}]}]} && !${SpawnCount[pc ${NetBots.Client[${i}]} radius ${MaxResponseDist}]}) {
				/varset OutOfRange ${OutOfRange}${NetBots.Client[${i}]},
				/varcalc OutOfRangeCount ${OutOfRangeCount} + 1
			} else {
				/varcalc InRangeCount ${InRangeCount} + 1
			}
		/next i
	}
	/if (${NetBots.Counts} < 2) {
		/echo ------------------------------------------
		/echo No other NetBots are connected.
		/echo ------------------------------------------
	} else {
		/echo ------------------------------------------
		/echo [${NetBots.Counts}] NetBots connected.
		/echo ------------------------------------------
	}
	/if (${InRangeCount} > 1) {
		/echo [${InRangeCount}] NetBots are present.
		/echo ------------------------------------------
	}
	/if (${OutOfRange.Length}) {
		/varset i 1
		/echo [${OutOfRangeCount}] NetBots out of range:
		:next_OutOfRange
		/echo ----- ${OutOfRange.Arg[${i},,]}, ${Int[${Spawn[pc ${OutOfRange.Arg[${i},,]}].Distance}]} units away.
		/varcalc i ${i} + 1
		/if (${OutOfRange.Arg[${i},,].Length}) /goto :next_OutOfRange
		/echo ------------------------------------------
	}
	/if (${OutOfZone.Length}) {
		/varset i 1

		/echo [${OutOfZoneCount}] NetBots out of zone:
		:next_OutOfZone
		/echo ----- ${OutOfZone.Arg[${i},,]} is in, ${Zone[${NetBots[${OutOfZone.Arg[${i},,]}].Zone}]}.
		/varcalc i ${i} + 1
		/if (${OutOfZone.Arg[${i},,].Length}) /goto :next_OutOfZone
		/echo ------------------------------------------
	}
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_CountBots -|
/RETURN

|----------------------------------------------------|
|- Preforms item swaps, listed in Character_Inis.	  -|
|----------------------------------------------------|
#EVENT Swap_Items "<#*#> Swap #1#"
#EVENT Swap_Items "[MQ2] Swap #1#"
SUB EVENT_Swap_Items(line, IniEntry)
/if (${Debug} || ${Debug_Basics}) /echo |- Event Swap_Items ==>
	| If I don't have a matching Ini entry.
	/if (!${Ini[${Character_Ini},Swap Items,${IniEntry}].Length}) {
		/echo \ay << Swap_Items: I have no listing for [${IniEntry}]. >>
	} else {
		/if (${Cursor.ID}) /call ClearCursor
		/if (${Bool[${Me.Casting}]} && ${Me.Class.ShortName.NotEqual[BRD]}) {
		  /delay 3s !${Me.Casting.ID}
      /call interrupt
      /delay 3s !${Me.Casting.ID}
    }
		/declare i int local 1
		/declare itemToSwap string local
		/declare slotToSwap string local
		
		:SwapLoop
		/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_Swap_Items -| Swaploop.
		
		/varset itemToSwap ${Ini[${Character_Ini},Swap Items,${IniEntry}].Arg[${i},/].Arg[1,|]}
		/varset slotToSwap ${Ini[${Character_Ini},Swap Items,${IniEntry}].Arg[${i},/].Arg[2,|]}
		
		| If I don't have the item in my inventory.
		|/echo ${Ini[${Character_Ini},Swap Items,${IniEntry}].Arg[1,/].Length}
		/if (!${FindItemCount[${itemToSwap}]}) {
			/echo |- Event Swap_Items -| #*# Error #*# [${itemToSwap}] was not found.
      /varcalc i ${i} + 1
			/if (${Ini[${Character_Ini},Swap Items,${IniEntry}].Arg[${i},/].Length}) /goto :SwapLoop
		} else {
			| If I'm swapping in a 2 hander, while dual wielding.
			/if (${slotToSwap.Equal[Mainhand]} && ${FindItem[${itemToSwap}].Type.Left[2].Equal[2H]} && ${Bool[${InvSlot[Offhand].Item}]}) {
			  /unequip Offhand
			  /delay 2
      }
      /if (${slotToSwap.Equal[Mainhand]} && ${FindItem[${itemToSwap}].ItemSlot}==14) {
        /unequip Offhand
        /delay 2
      }
      /if (${slotToSwap.Equal[Offhand]} && ${FindItem[${itemToSwap}].ItemSlot}==13) {
        /unequip Mainhand
        /delay 2
      }
			| Swap in item.
      |/if (${Debug} || ${Debug_Basics})
      /echo Equipping [${itemToSwap}] ${slotToSwap}
			/call SwapItem "${itemToSwap}" ${slotToSwap}
			/delay 2
			/varcalc i ${i} + 1
			/if (${Ini[${Character_Ini},Swap Items,${IniEntry}].Arg[${i},/].Length}) /goto :SwapLoop
		}
	}
/if (${Debug} || ${Debug_Basics}) /echo <== Swap_Items -|
/RETURN

|----------------------------------------------------|
|- Ends the macro before a bot finishes camping.	  -|
|----------------------------------------------------|
#EVENT EndMacro "It will take about 20 more seconds to prepare your camp."
SUB EVENT_EndMacro
	/echo User is camping, ending macro.
	/endmacro
/RETURN

|------------------------------------------------|
|- Engages MedBreak mode, on bots who can cast.	-|
|------------------------------------------------|
#EVENT medOn "<#1#> MedBreak On#*#"
SUB EVENT_medOn(line, ChatSender)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_medOn ==>
  /if (!${checkEventArgs[${ChatSender},${line},UZR]}) /return
  /if (${Me.Class.ShortName.NotEqual[BRD]}) {
      /docommand ${ChatToggle} Meditating...
      /varset medBreak TRUE
	  /if (${Select[${Me.Class.ShortName},CLR,DRU,ENC,MAG,NEC,SHM,WIZ]}) /varset AssistType Off
      /if (${line.Find[ Hold]}) {
        /varset medBreak_Hold TRUE
      } else {
        /varset medBreak_Hold FALSE
      }
  }
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_medOn -|
/RETURN

|----------------------------------------------------|
|- disengages MedBreak mode, on bots who can cast.	-|
|----------------------------------------------------|
#EVENT medOff "<#1#> MedBreak Off"
SUB EVENT_medOff(line, ChatSender)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_medOff ==>
  /if (!${checkEventArgs[${ChatSender},${line},UZR]}) /return
  /if (${medBreak}) {
    /docommand ${ChatToggle} Ending Medbreak.
    /varset medBreak FALSE
    /varset medBreak_Hold FALSE
	/if (${Ini[${Character_Ini},Assist Settings,Assist Type (Melee/Ranged/Off)].Length}) /call iniToVarV "${Character_Ini},Assist Settings,Assist Type (Melee/Ranged/Off)" AssistType string outer
    /if (${Me.Sitting}) /stand
  }
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_medOff -|
/RETURN

|--------------------------------------------------------------------------------|
|- Automatically disengages and re-engages MedBreak when conditions are met.	-|
|- Ends MedBreak mode at 99% mana, unless, 'MedBreak hold command is given.		-|
|--------------------------------------------------------------------------------|
SUB check_MedBreak
/if (${Debug} || ${Debug_Basics}) /echo |- check_MedBreak ==>
	| If End MedBreak in Combat (On/Off)=On in General and Character, and a netbot is in combat, call medOff
	/if (${medOn_combatBreak} && ${medOn_combatBreakChar} && ${Me.CombatState.Equal[COMBAT]}) {
    /docommand ${ChatToggle} Ending Medbreak early due to combat.
    /varset medBreak FALSE
    /varset medBreak_Hold FALSE
	/if (${Ini[${Character_Ini},Assist Settings,Assist Type (Melee/Ranged/Off)].Length}) /call iniToVarV "${Character_Ini},Assist Settings,Assist Type (Melee/Ranged/Off)" AssistType string outer
    /if (${Me.Sitting}) /stand
	}
	/if (!${Me.Feigning}) {
		/if (!${medbreak_Popup_Timer}) {
			/popup ***Meditating***
			/varset medbreak_Popup_Timer 30
		}
		| end MedBreak when we are full mana or end for melee, unless hold is engaged
		/if (${medBreak} && !${medBreak_Hold} && (${Me.PctMana} >= 99 || (${Me.MaxMana} ==0 && ${Me.PctEndurance}>=99))) {
			/docommand ${ChatToggle} Full Mana/Endurance, ending MedBreak.
			/if (${Me.Sitting}) /stand
			/varset medBreak FALSE
			/varset medBreak_Hold FALSE	
			/if (${Ini[${Character_Ini},Assist Settings,Assist Type (Melee/Ranged/Off)].Length}) /call iniToVarV "${Character_Ini},Assist Settings,Assist Type (Melee/Ranged/Off)" AssistType string outer			
		} else {
      /if (!${Me.Sitting} && !${Me.Casting.ID} && !${Me.Moving}) /sit
		}
	}
/if (${Debug} || ${Debug_Basics}) /echo <== check_MedBreak -|
/RETURN

|--------------------------------------------------------------------------------|
#EVENT set_AAXP "<#1#> Set AA XP #2#"
#EVENT set_AAXP "[#1#] Set AA XP #2#"
SUB EVENT_set_AAXP(line, ChatSender, eventParams)
/if (${Debug} || ${Debug_Basics}) /echo |- set_AAXP ==>
  /if (!${checkEventArgs[${ChatSender},${line},U,${eventParams}]}) /return
  /varset eventParams ${Int[${c_eventArgData}]}
  /echo Setting AA XP [${eventParams}%].
  /alternateadv ON ${eventParams}
/if (${Debug} || ${Debug_Basics}) /echo <== set_AAXP -|
/RETURN

|--------------------------------------------------------------------------------|
#EVENT fixCorpses "<#*#> Fix Corpses"
SUB EVENT_fixCorpses
	/echo Attempting to reset corpse positions...
	/hidecorpse all
	/delay 2
	/hidecorpse none
	/delay 2
	/hidecorpse looted
/RETURN

|----------------------------------------|
|- Consents a PC to drag your corpse.	-|
|----------------------------------------|
#event Consent "#1# tells you, 'Consent #2#'"
#event Consent "#1# tells the raid#*#Consent #2#'"
#event Consent "<#1#> Consent #2#"
SUB Event_Consent(line, ChatSender, ConsentTarget)
  /if (${ConsentTarget.NotEqual[${Me.CleanName}]}) /consent ${ConsentTarget}
/RETURN

|--------------------------------------------------------------------------------|
#event gatherCorpses "[MQ2] Gather corpse#*#"
SUB event_gatherCorpses
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_gatherCorpses ==>
  /if (${Raid.Members}) {
    /rs Consent ${Me.CleanName}
  } else {
    /bc Consent ${Me.CleanName}
  }
	/declare i int local
	/for i 1 to ${SpawnCount[pccorpse radius 100]}
    /call TrueTarget ${Spawn[${NearestSpawn[${i},pccorpse radius 100]}].ID}
    /delay 2
    /corpse
    /delay 1s ${Target.Distance} < 20
	/next i
	/squelch /target clear
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_gatherCorpses -|
/RETURN

|-------------------------------
|- All bots click yes or no to confirmation boxes.
|-------------------------------
#EVENT ClickYes	"<#1#> Click #2#"
SUB EVENT_ClickYes(line, ChatSender, eventParams)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_ClickYes ==>
  /if (!${checkEventArgs[${ChatSender},${line},U,${eventParams}]}) /return
  /declare buttonToClick string local ${If[${c_eventArgData.Find[yes]},Yes,No]}
  /declare miscTimer timer local 5s
  /if (${c_eventArgChatSender.Equal[${Me}]}) /delay 2s
  :clickButton
  /if (${Window[ConfirmationDialogBox].Open}) {
    /notify ConfirmationDialogBox ${buttonToClick}_Button leftmouseup
  } else /if (${Window[LargeDialogWindow].Open}) {
    /notify LargeDialogWindow LDW_${buttonToClick}Button leftmouseup
  }
  /if (${miscTimer}) {
    /if (${Window[ConfirmationDialogBox].Open} || ${Window[LargeDialogWindow].Open}) /goto :clickButton
  }
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_ClickYes -|	
/RETURN

|--------------------------------------------------------|
|- Attempt to gate on all bots.							-|
|--------------------------------------------------------|
|- Use, /bc gate, /tell 'Name' [Gate], or, /g [Gate].	-|
|--------------------------------------------------------|
#EVENT gate	"<#1#> Gate"
#EVENT gate "#1# tells you, 'Gate'"
#EVENT gate "#1# tell your party, 'Gate'"
#EVENT gate "#1# tells the group, 'Gate'"
SUB EVENT_gate(line, ChatSender)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_Gate ==>
  /if (${line.Find[,]}) /varset line ${line.Left[${Math.Calc[${line.Find[,]}-1]}]} ${line.Right[-${line.Find[,]}]}
  /if (!${checkEventArgs[${ChatSender},${line},UZ,""]}) /return
  /if (!${Me.Book[gate]}) {
    /if (${FindItem[Philter of Major Translocation].ID}) {
      /docommand ${ChatToggle} Preparing to gate...
      /call castSimpleSpell "Philter of Major Translocation" ${Me.ID}
    } else /if (${FindItem[Vial of Swirling Smoke].ID}) {
      /docommand ${ChatToggle} Preparing to gate...
      /call castSimpleSpell "Vial of Swirling Smoke" ${Me.ID}
    } else /if (${FindItem[Gate Potion].ID}) {
      /docommand ${ChatToggle} Preparing to gate...
      /call castSimpleSpell "Gate Potion" ${Me.ID}
    } else {
      /docommand ${ChatToggle} I am not able to gate at this time.
    }
  } else {
    /docommand ${ChatToggle} Preparing to gate...
    /call castSimpleSpell "Gate" ${Me.ID}
   }
/RETURN 

|--------------------------------------------------------|
|- Request evac from bots set to Evac_OnCommand.		-|
|--------------------------------------------------------|
|- Use, /bc Evac, /tell 'Name' Evac
|--------------------------------------------------------|
#EVENT Evacuate "[#1#] Evac"
#EVENT Evacuate	"<#1#> Evac"
#EVENT Evacuate "#1# tells you, 'Evac'"
#EVENT Evacuate "#1# tell your party, 'Evac'"
#EVENT Evacuate "#1# tells the group, 'Evac'"
SUB EVENT_Evacuate(line, ChatSender)
/if (${Debug} || ${Debug_Basics}) /echo |- EVENT_Evacuate ==>
  /if (${Select[${Me.Class.ShortName},DRU,WIZ]}) {
    /if (${line.Find[,]}) /varset line ${line.Left[${Math.Calc[${line.Find[,]}-1]}]} ${line.Right[-${line.Find[,]}]}
    /if (!${checkEventArgs[${ChatSender},${line},UZ,""]}) /return
    /if (${Bool[${Group.Member[${c_eventArgChatSender}]}]} && ${NetBots.Counts}>6) /delay 1s
    /if (${Me.AltAbilityReady[Exodus]}) {
      /delay 3
      /docommand ${ChatToggle} Evacuating!
      /call interrupt
      /call castSimpleSpell "Exodus" ${Me.ID}
	  
    } else /if (${Me.Book[${Evac_Spell.Arg[1,/]}]}) {
      /docommand ${ChatToggle} Evacuating!
      /call interrupt
      /call castSimpleSpell "${Evac_Spell.Arg[1,/]}" ${Me.ID}
	} else {
      /docommand ${ChatToggle} I am not able to Evac at this time.
    }
  }
/if (${Debug} || ${Debug_Basics}) /echo <== EVENT_Evacuate -|
/RETURN

|----------------------------------------|
|- Automatically accepts raid invites.	-|
|----------------------------------------|
#EVENT RaidAccept "#*#invites you to join a raid.#*#"
SUB EVENT_RaidAccept
  /delay 5
  /notify ConfirmationDialogBox Yes_Button leftmouseup
  /delay 5
  /raidaccept
/RETURN

|----------------------------------------|
|- Automatically accepts group invites.	-|
|----------------------------------------|
#EVENT Invite "#1# invites you to join a group."
SUB EVENT_Invite(line, ChatSender)
/if (${Debug}) /echo |- EVENT_Invite ==>
  /if (!${checkEventArgs[${ChatSender},${line},U,""]}) /return
  /if (${Me.Casting.ID} && ${Me.Class.ShortName.NotEqual[BRD]}) {
    /call interrupt
    /delay 5s !${Me.Casting.ID}
  }
  /declare retryTimer timer local 5s
  :retry_Invite
  /squelch /target clear
  /delay 3
  /invite
  /delay 1s ${Bool[${Group}]}
  /if (!${Bool[${Group}]}) {
    /if (${retryTimer}) {
      /goto :retry_Invite
    } else {
      /echo Failed to join the group.
    }
  }
/if (${Debug}) /echo <== EVENT_Invite -|
/RETURN

|--------------------------------------------------------------------------------------------|
|- Groupleaders save current group formations to the Groups.ini file, to be recalled later.	-|
|--------------------------------------------------------------------------------------------|
|- Use, /savegroup 'Name', /bc Save Group 'Name', or /bc SetGroup 'Name'					-|
|--------------------------------------------------------------------------------------------|
#EVENT saveGroup "<#1#> Save Group #2#"
SUB EVENT_saveGroup(line, ChatSender, eventParams)
/if (${Debug}) /echo |- EVENT_saveGroup ==>
  /if (!${checkEventArgs[${ChatSender},${line},U,${eventParams}]}) /return
  /if (!${Select[${Group.Leader},${Me}]}) {
    /if (${Debug}) /echo I am not a group leader, skipping.
  } else {
    /echo Preparing to save...
    /declare groupName string local ${c_eventArgData}
    /if (${groupName.Right[1].Equal[ ]}) /varset groupName ${groupName.Left[${Math.Calc[${groupName.Length}-1]}]}
    |/delay ${Math.Rand[25]}
    /declare uniqueID int local
    /declare i int local
    /declare e int local
    | Set a random ID to associate with out group name.
    /for i 1 to ${NetBots.Counts}
      /if (${NetBots.Client[${i}].Equal[${Me.CleanName}]}) {
        /varset uniqueID ${i}
      }
    /next i
    | Check to see if existing entries need to be overwritten.
    | Only savegroup caller overwrites existing
    /if (${c_eventArgChatSender.Equal[${Me.CleanName}]}) {
      /if (${Ini[${Group_Ini}].Find[${groupName}]}) {
        /echo Overwriting existing saved group(s)...
        /varset i 1
        :next_groupName
        /if (${Ini[${Group_Ini}].Arg[${i},|].Length}) {
          /if (${Ini[${Group_Ini}].Arg[${i},|].Arg[2,_].Equal[${groupName}]}) {
            /for e 0 to 5
              /call WriteToIni "${Group_Ini},${Ini[${Group_Ini}].Arg[${i},|]},GroupMember#${e}" "DEPRECATED" 1
            /next e
          }
          /varcalc i ${i}+1
          /goto :next_groupName
        }
      }
    } else {
      /delay 2s
    }
    | Delay for a moment to allow other bots to catch up, so they don't overwrite our soon to be saved group.
    /delay ${Math.Rand[25]}
    | Save the group configuration
    /echo Group configuration(s) saved. Use [/group ${groupName}] to recall this group setup.
    /for i 0 to 5
      | -Save group members 0-5.
      /if (${Bool[${Group.Member[${i}]}]}) {
        /call WriteToIni "${Group_Ini},${MacroQuest.Server}_${groupName}_${uniqueID},GroupMember#${i}" ${Group.Member[${i}]} 1
      | -If the group has less that 5 members, set placeholders
      } else {
        /call WriteToIni "${Group_Ini},${MacroQuest.Server}_${groupName}_${uniqueID},GroupMember#${i}" PLACEHOLDER 1
      }
    /next i
  }
/if (${Debug}) /echo <== EVENT_saveGroup -|
/RETURN

|---------------------------------------------------------|
|- Lists all saved group setups, on your current server. -|
|---------------------------------------------------------|
#EVENT listGroups "<#1#> List Groups"
#EVENT listGroups "<#1#> ListGroups"
SUB EVENT_listGroups
/if (${Debug}) /echo |- listGroups ==>
	| -Check Group_Ini for groups on this server.
	/if (!${Ini[${Group_Ini}].Find[${MacroQuest.Server}]}) {
		/echo You don't have any group setups saved on, [${MacroQuest.Server}].
	} else {
		/declare i int local 1
		/declare e int local
		
		:next_groupListing

		/if (${Ini[${Group_Ini}].Arg[${i},|].Arg[1,_].Find[${MacroQuest.Server}]}) {
			/echo
			/echo --- Group: [${Ini[${Group_Ini}].Arg[${i},|].Arg[2,_]}] ---
			| -Reset 'e' the group member counting variable.
			/varset e 1
			
			:next_memberListing
			| -Check that the entry is not a PLACEHOLDER.
			/if (${Ini[${Group_Ini},${Ini[${Group_Ini}].Arg[${i},|]},${Ini[${Group_Ini},${Ini[${Group_Ini}].Arg[${i},|]}].Arg[${e},|]}].NotEqual[PLACEHOLDER]}) {
				/echo Group member#${e}: ${Ini[${Group_Ini},${Ini[${Group_Ini}].Arg[${i},|]},${Ini[${Group_Ini},${Ini[${Group_Ini}].Arg[${i},|]}].Arg[${e},|]}]}
				/varcalc e ${e} + 1
				/if (${Ini[${Group_Ini},${Ini[${Group_Ini}].Arg[${i},|]},${Ini[${Group_Ini},${Ini[${Group_Ini}].Arg[${i},|]}].Arg[${e},|]}].Length}) /goto :next_memberListing
			}
		}
		/varcalc i ${i} + 1
		/if (${Ini[${Group_Ini}].Arg[${i},|].Length}) /goto :next_groupListing
		/echo
	}
/if (${Debug}) /echo <== listGroups -|
/RETURN

|------------------------------------------------|
|- Recalls groups saved in your Groups.ini.		-|
|------------------------------------------------|
|- Use, /group 'Name', or, /bc Group 'Name'.	-|
|------------------------------------------------|
#EVENT groupUp "<#1#> Group #2#"
SUB EVENT_groupUp(line, ChatSender, createGroup)
/if (${Debug}) /echo |- EVENT_groupUp ==>
  /if (!${checkEventArgs[${ChatSender},${line},U,${createGroup}]}) /return
  /if (${c_eventArgChatSender.Equal[${Me.Name}]}) {
    /squelch /bca //raiddisband
    /squelch /bca //disband
    /delay 5
    /if (${Raid.Members}) /raiddisband
  }
  /delay 5

  /declare groupName string local ${c_eventArgData}
  /declare groupFound string local
  /declare groupMembers[5] string local
  /declare groupSize int local
  /declare i int local 1
  /declare e int local

  | -Check for groupName in Group_Ini.
  :nextGroupListing
  /if (${${IniMode}[${Group_Ini}].Arg[${i},|].Arg[2,_].Equal[${groupName}]} && ${${IniMode}[${Group_Ini},${${IniMode}[${Group_Ini}].Arg[${i},|]},GroupMember#0].NotEqual[DEPRECATED]}) {
    | check to see if I am the group leader(GroupMember#0)
    /if (${${IniMode}[${Group_Ini},${${IniMode}[${Group_Ini}].Arg[${i},|]},GroupMember#0].Equal[${Me.CleanName}]}) {
      /echo Recalling [${groupName}]...
      /delay 15
      | Invite group members while ignoring placeholders, and set
      /for e 1 to 5
      /varset groupMembers[${e}] ${${IniMode}[${Group_Ini},${${IniMode}[${Group_Ini}].Arg[${i},|]},GroupMember#${e}]}
      /if (${${IniMode}[${Group_Ini},${${IniMode}[${Group_Ini}].Arg[${i},|]},GroupMember#${e}].NotEqual[PLACEHOLDER]}) {
        /varcalc groupSize ${groupSize}+1
        | -Alert PC of incoming group invite.
        /invite ${groupMembers[${e}]}
      }
      /next e

      /delay 8s ${Group} == ${groupSize}
      /if (${Group} != ${groupSize}) {
        /for e 1 to 5
        /if (${groupMembers[${e}].NotEqual[PLACEHOLDER]} && !${Bool[${Group.Member[${groupMembers[${e}]}]}]}) /docommand ${ChatToggle} [${groupMembers[${e}]}] Did not join the group...
        /next e
      }
      /goto :skip
    }
  }
  /varcalc i ${i}+1
  /if (${${IniMode}[${Group_Ini}].Arg[${i},|].Length}) /goto :nextGroupListing
 :skip
/if (${Debug}) /echo <== EVENT_groupUp -|
/RETURN

|---------------------------|
#EVENT exp_group "[#1#] ExpGroup #2#"
#EVENT exp_group "<#1#> ExpGroup #2#"
#EVENT exp_group "#1# tells the group, 'ExpGroup #2#'"
#EVENT exp_group "#1# tell your party, 'ExpGroup #2#'"
SUB EVENT_exp_group(line, ChatSender, expToggle)
  /if (${line.Find[,]}) /varset line ${line.Left[${Math.Calc[${line.Find[,]}-1]}]} ${line.Right[-${line.Find[,]}]}
  /if (!${checkEventArgs[${ChatSender},${line},UZ,${expToggle}]}) /return
  /if (${Select[${c_eventArgData},On,Yes,True,1]} > 0) {
    /call IniToArrayV "${Character_Ini},Melee Abilities,Ability#" MyAbilities
    /if (${Defined[MyAbilities]})	/call BuildSpellArray "MyAbilities" "Abilities2D"
    /if (${Me.Class.ShortName.Equal[Rog]}) {
      /call buff_SpellArrays
      /if (${Defined[strikeDiscStr]} && ${Defined[strikeDisc]}) {
        /varset strikeDisc ${strikeDiscStr.Arg[1,/]}
      }
    }
    /if (${Ini[${Character_Ini},Nukes,${KSSpellSet}].Length}) /call event_SpellSet "PLACEHOLDER" "${Me}" ${KSSpellSet}
    /if (${Ini[${Character_Ini},Swap Items,${KSWeaponSet}].Length}) /swap ${KSWeaponSet}
    /echo \ag KS Mode Activated - get exp

  |remove anything that could kos when out of group
  } else /if (${Select[${c_eventArgData},Off,No,False,0]} > 0) {
    /if (${Select[${Me.Class.ShortName},${Ini[${genSettings_Ini},ExpGroup,NoCombatAbil]}]}) {
      /if (${Defined[MyAbilities]}) /deletevar MyAbilities
      /if (${Defined[Abilities2D]}) /deletevar Abilities2D
    }
    /if (${Ini[${Character_Ini},Nukes,${NoKSSpellSet}].Length}) /call event_SpellSet "PLACEHOLDER" "${Me}" ${NoKSSpellSet}
    /if (${Defined[NoKSWeaponSet]} && ${Ini[${Character_Ini},Swap Items,${NoKSWeaponSet}].Length}) /swap ${NoKSWeaponSet}
    /if (${Me.Class.ShortName.Equal[Rog]}) {
      /if (${Defined[strikeDisc]}) /varset strikeDisc 0
      /declare poisonInUse string local
      /declare i int local
      :remove_poisons
        /if (${Defined[poisonPR]}) {
          /if (${Bool[${Me.Buff[${FindItem[=${poisonPR}].Spell}]}]}) {
            /varset poisonInUse ${poisonPR}
          }
        }
        /if (${Defined[poisonFR]}) {
          /if (${Bool[${Me.Buff[${FindItem[=${poisonFR}].Spell}]}]}) {
            /varset poisonInUse ${poisonFR}
          }
        }
        /if (${Defined[poisonCR]}) {
          /if (${Bool[${Me.Buff[${FindItem[=${poisonCR}].Spell}]}]}) {
            /varset poisonInUse ${poisonCR}
          }
        }
        /if (${Defined[CombatBuffs2D]}) {
          /for i 1 to ${CombatBuffs2D.Size[1]}
            /if (${CombatBuffs2D[${i},${iCastName}].Find[${poisonInUse}]}) {
              /call RemoveSpellArrayElement "CombatBuffs2D" ${i}
              /goto :remove_poisons
            }
          /next i
        }
      /if (${Defined[SelfBuffs2D]}) {
        /for i 1 to ${SelfBuffs2D.Size[1]}
          /if (${SelfBuffs2D[${i},${iCastName}].Find[${poisonInUse}]}) {
            /call RemoveSpellArrayElement "SelfBuffs2D" ${i}
            /goto :remove_poisons
          }
        /next i
      }
      /echo ${poisonInUse}, ${poisonPR},${poisonFR},${poisonCR}
      /squelch ${Me.Buff[${FindItem[=${poisonInUse}].Spell}].Remove}
    }
    /echo \ag NoKS Mode Activated - do not get exp
  }
/return

|---------------------------|
#EVENT reportMana "<#1#> Report mana#*#"
SUB EVENT_reportMana(line,ChatSender)
/if (${Me.Class.CanCast}) {
  /if (!${checkEventArgs[${ChatSender},${line},UZ,""]}) /return
  /if (${Me.PctMana}<100) /docommand ${ChatToggle} ${Me.PctMana}m
}
/RETURN

|---------------------------|
#EVENT campDesktop "<#1#> CampDesktop"
SUB campDesktop(line,ChatSender)
  /if (!${checkEventArgs[${ChatSender},${line},UZ,${expToggle}]}) /return
  /camp desktop
  /endmacro
/RETURN

Sub basics_Setup
/call iniToVarV "${advSettings_Ini},Debug,Debug Basics (On/Off)" Debug_Basics bool outer
/if (${Debug} || ${Debug_Basics}) /echo |- basics_Setup ==>

	/if (!${Defined[Following]}) /declare Following bool global FALSE
	/if (!${Defined[FollowTarget]}) /declare FollowTarget string global NULL
	/declare FollowCheckTimer timer outer

  /if (!${Defined[barkTarget]}) /declare barkTarget string outer
  /if (!${Defined[barkReturned]}) /declare barkReturned bool outer FALSE

	/declare event_counter int outer 0

  /declare c_checkSelectedBots  bool outer
	/declare c_eventArg           bool outer
	/declare c_eventArgChatSender string outer
  /declare c_eventArgData       string outer
  /declare c_argueString        string outer

	/declare medBreak bool outer FALSE
	/declare medBreak_Hold bool outer FALSE
	/declare medOn_combatBreak bool outer FALSE
	/declare autoMedChar bool outer FALSE
	/declare medbreak_Popup_Timer timer outer
	/declare clickitRandomDelay int outer 7

	/if (${Ini[${genSettings_Ini},ExpGroup,NoKS_WeaponSet].Length}) 		/call iniToVarV "${genSettings_Ini},ExpGroup,NoKS_WeaponSet" NoKSWeaponSet string outer
	/if (${Ini[${genSettings_Ini},ExpGroup,KS_WeaponSet].Length}) 			/call iniToVarV "${genSettings_Ini},ExpGroup,KS_WeaponSet" KSWeaponSet string outer
	/if (${Ini[${genSettings_Ini},ExpGroup,NoKS_SpellSet].Length}) 			/call iniToVarV "${genSettings_Ini},ExpGroup,NoKS_SpellSet" NoKSSpellSet string outer
	/if (${Ini[${genSettings_Ini},ExpGroup,KS_SpellSet].Length}) 				/call iniToVarV "${genSettings_Ini},ExpGroup,KS_SpellSet" KSSpellSet string outer

	/declare MaxResponseDist int outer 250
	/if (${Ini[${genSettings_Ini},General,Max Response Distance].Length} && ${Int[${Ini[${genSettings_Ini},General,Max Response Distance]}]}) /call iniToVarV "${genSettings_Ini},General,Max Response Distance" MaxResponseDist int outer

	/declare LeashLength int outer 100
	/if (${Ini[${genSettings_Ini},General,Leash Length].Length} && ${Int[${Ini[${genSettings_Ini},General,Leash Length]}]}) /call iniToVarV "${genSettings_Ini},General,Leash Length" LeashLength int outer
	/if (${Ini[${genSettings_Ini},General,End MedBreak in Combat(On/Off)].Length}) /call iniToVarV "${genSettings_Ini},General,End MedBreak in Combat(On/Off)" medOn_combatBreak bool outer
	/if (${Ini[${genSettings_Ini},General,AutoMedBreak PctMana].Length}) /call iniToVarV "${genSettings_Ini},General,AutoMedBreak PctMana" autoMedPctMana int outer
  	/if (${Ini[${Character_Ini},Misc,End MedBreak in Combat(On/Off)].Length}) /call iniToVarV "${Character_Ini},Misc,End MedBreak in Combat(On/Off)" medOn_combatBreakChar bool outer
	/if (${Ini[${Character_Ini},Misc,AutoMedBreak (On/Off)].Length}) /call iniToVarV "${Character_Ini},Misc,AutoMedBreak (On/Off)" autoMedChar bool outer
	| -Add Groups_Ini file path
	/if (!${Ini[${MacroData_Ini},File Paths,Saved Groups].Length}) /call WriteToIni "${MacroData_Ini},File Paths,Saved Groups" "e3 Macro Inis\Saved Groups.ini" 1
	| -Import Groups_Ini.
	/if (!${Ini[${MacroData_Ini},File Paths,Saved Groups].Length}) {
		/echo ERROR: Could not find designated file path for [Saved Groups], please review [${MacroData_Ini}] and restart.
    /beep
		/endmacro
	} else {
		/declare Group_Ini string outer ${Ini[${MacroData_Ini},File Paths,Saved Groups]}
	}
/if (${Debug} || ${Debug_Basics}) /echo <== basics_Setup -|
/return



Sub basics_Background_Events
	/doevents Follow
	/doevents Stop
  /doevents MoveHere
  /doevents clickIt
  /doevents oldclickIt
  /doevents bark
  /doevents reportMana
  /doevents groupUp
  /doevents listGroups
  /doevents saveGroup
  /doevents Invite
  /doevents RaidAccept
  /doevents Evacuate
  /doevents gate
  /doevents ClickYes
  /doevents gatherCorpses
  /doevents addConsent
  /doevents Consent
  /doevents fixCorpses
  /doevents set_AAXP
  /doevents medOff
  /doevents medOn
  /doevents EndMacro
  /doevents castItem
  /doevents Swap_Items
  /doevents CountBots
  /doevents FindMissingItem
  /doevents FindItems
  /doevents FindItemCompact
  /doevents FindSlot
  /doevents CheckBuffs
  /doevents LoadSpells
  /doevents Exit
  /doevents dropInvis
  /doevents dropBuff
  /doevents runThruZone
  /doevents macroHelp
  /doevents exp_group
  /doevents campdesktop
  /doevents gimme
  /doevents LinkLoot
  /doevents collect
  /doevents sendInstanceInvites
  /doevents manastoneToggle
  /doevents outOfSomething
  /doevents ItemDeleteSummoned
  /call check_StoneOn
|		/varset event_counter 1
|	} else {
|		/varcalc event_counter ${event_counter}+1
|	}
/return

SUB basics_MacroSettings
/if (${Debug}) /echo |- basics_MacroSettings ==>
	/call WriteToIni "${advSettings_Ini},Debug,Debug Basics (On/Off)" Off
	/call WriteToIni "${genSettings_Ini},General,Max Response Distance" 500
	/call WriteToIni "${genSettings_Ini},General,Leash Length" 250
	/call WriteToIni "${genSettings_Ini},General,End MedBreak in Combat(On/Off)" On
  /call WriteToIni "${genSettings_Ini},General,AutoMedBreak PctMana" 0

	/call WriteToIni "${genSettings_Ini},ExpGroup,NoKS_WeaponSet" NoExp
	/call WriteToIni "${genSettings_Ini},ExpGroup,NoKS_SpellSet" NoExp
	/call WriteToIni "${genSettings_Ini},ExpGroup,KS_WeaponSet" Main
	/call WriteToIni "${genSettings_Ini},ExpGroup,KS_SpellSet" Exp

/if (${Debug}) /echo <== basics_MacroSettings -|
/RETURN

SUB basics_CharacterSettings
/call WriteToIni "${Character_Ini},Misc,AutoFood" Off
/call WriteToIni "${Character_Ini},Misc,Food"
/call WriteToIni "${Character_Ini},Misc,Drink"
/if (${Select[${Me.Class.ShortName},CLR,DRU,ENC,MAG,NEC,SHM,WIZ]}) {
	/call WriteToIni "${Character_Ini},Misc,End MedBreak in Combat(On/Off)" Off
} else /if (${Me.Class.ShortName.NotEqual[BRD]}) {
	/call WriteToIni "${Character_Ini},Misc,End MedBreak in Combat(On/Off)" On
}
/if (${Me.Class.ShortName.NotEqual[BRD]}) /call WriteToIni "${Character_Ini},Misc,AutoMedBreak (On/Off)" Off
/RETURN

Sub basics_Aliases
/if (${Debug}) /echo |- basics_Aliases ==>
	/noparse /squelch /alias /followon /bc [+g+]Follow ${Me.CleanName}
	/noparse /squelch /alias /followme /bc [+g+]Follow ${Me.CleanName}
	/noparse /squelch /alias /followit /bc [+g+]Follow ${Target.CleanName}
  /squelch /alias /followoff /bc [+r+]Stop
	/squelch /alias /stop /bc [+r+]Stop
  /noparse /squelch /alias /stopf /bcaa //StopFollowing ${Me.Y} ${Me.X}
  /noparse /squelch /alias /mtm /bc Move to ${Me.ID}
  /noparse /squelch /alias /movetome /bc Move to ${Me.ID}
	/noparse /squelch /alias /mtt /bc Move to ${Target.ID}
  /noparse /squelch /alias /movetotarget /bc Move to ${Target.ID}
	/noparse /squelch /alias /Bark /bc Bark at ${Target.ID}
  /squelch /alias /ClickIt /bc Click It
  /noparse /squelch /alias /oClickIt /bc OldClickit ${Me.Loc.Replace[ ,]}
	/noparse /squelch /alias /RunThruZone /bc Run through zone at ${Me.Loc.Replace[ ,]},${Me.Heading.Degrees}
	/noparse /squelch /alias /RunThroughZone /bc Run through zone at ${Me.Loc.Replace[ ,]},${Me.Heading.Degrees}
	|/noparse /squelch /alias /RTZ /bc Run through zone at ${Me.Loc.Replace[ ,]},${Me.Heading.Degrees}
  /noparse /squelch /alias /RTZ /bc Run through zone
	/squelch /alias /ClickYes /bc Click yes
	/squelch /alias /Yes /bc Click yes
	/squelch /alias /ClickNo /bc Click No
	/squelch /alias /No /bc Click No
	/squelch /alias /DropInvis /bc Drop Invisibility
	/squelch /alias /BotExit /bc Exit
	/squelch /alias /Gate /bc Gate
	/squelch /alias /Evac /bc Evac
	/squelch /alias /LoadSpells /bc Load Spells
	/squelch /alias /DropBuff /bc Drop Buff
	/squelch /alias /CheckBuff /bc Check Buff
  /squelch /alias /FindItemC /bc Find ItemC
	/squelch /alias /FindItem /bc Find Item
  /squelch /alias /FindSlot /bc Find Slot
  /squelch /alias /fds /bc Find Slot
  /squelch /alias /fdi /bc Find Item
  /squelch /alias /fic /bc Find ItemC
  /squelch /alias /FindMissingItem /bc Find Missing Item
  /squelch /alias /fmi /bc Find Missing Item
	/noparse /squelch /alias /FindIt /bc Find Item ${Cursor}
	/squelch /alias /CountBots /echo Head Count
	/squelch /alias /Count /echo Head Count
	/squelch /alias /BotCount /echo Head Count
	/squelch /alias /RollCall /echo Head Count
	/squelch /alias /Swap /echo Swap
	/squelch /alias /useitem /useitem
	/noparse /squelch /alias /ConsentMe /bc Consent ${Me.CleanName}
	/squelch /alias /BotConsent /bc Consent
	/squelch /alias /Group /bc Group
	/squelch /alias /SaveGroup /bc Save Group
	/squelch /alias /SaveGroups /bc Save Group
	/squelch /alias /listgroups /bc List Groups
	/squelch /alias /medon /bc MedBreak On
	/squelch /alias /medoff /bc MedBreak Off
	/squelch /alias /SetAAXP /bc Set AA XP
	/squelch /alias /PortTo /bc Port to
	/squelch /alias /FixCorpses /bc Fix Corpses
	/squelch /alias /ResetCorpses /bc Fix Corpses
	/squelch /alias /gathercorpses /echo Gather Corpses
	/squelch /alias /mana /bc Report Mana
/if (${Debug}) /echo <== basics_Aliases -|
/return

|-----------------------------------------------------------|
|- When *anyone* asks for a Temporary/NoRent item it will
|- move to the requestor and trade the item to them.
|- If the requestor is a bot in the same NetBots it will also
|- accept the trade on both sides.
|- Permanent items requested from a bot in the same NetBots
|- will be given.
|- Must add /doevents gimme to basics_Background_Events in e3_Basics.ini
|-----------------------------------------------------------|
#event gimme "#1# tells you, 'Gimme #2#'"
#event gimme "<#1#> Gimme #2#"
#event gimme "[#1#(msg)] Gimme #2#"
sub event_gimme(line, ChatSender, RequestedItem)

  /declare DebugGimme false
	/declare SummonSpellCast 
	/if (${DebugGimme}) /echo |- event_gimme ==>
  /if (${Waiting4Rez}) /return
  /if (${Bool[${Me.Buff[Resurrection Sickness]}]}) /return
	/echo Gimme Event: ${ChatSender} has requested a ${RequestedItem}
	/declare senderLoc string local ${Spawn[${ChatSender}].Loc}
	/if (${DebugGimme}) /echo ${senderLoc}
	/if (${DebugGimme}) /echo Distance = ${Math.Distance[${senderLoc}]}
	/if (${Math.Distance[${Spawn[${ChatSender}].Loc}]}>100) {
		/call notifyViaBCTell  ${ChatSender} "You're too far away. Please move closer and ask again."
   	/return
	}
	/if (${Bool[${Cursor.ID}]} || ${medBreak} || ${Me.Invis} || ${Me.PctHPs} < 85 || ${Me.PctAggro} > 1 || ${Me.CombatState.Equal[COMBAT]} || ${Assisting} || ${Me.Moving} || ${Me.Combat}) {
    /call notifyViaBCTell  ${ChatSender} "I'm busy"
  	/return
	}
	/declare platOnCursor local false
	/target pc ${ChatSender}
	/declare IsMyBot bool local ${Bool[${Select[${ChatSender}, ${NetBots.Client}]}]}

  /if (!${Defined[GimmeSharing]}) {
    /if (${IniExt[${Character_Ini},Misc,GimmeSharing].Count} > 0) {
      /call iniToVarV "${Character_Ini},Misc,GimmeSharing" GimmeSharing bool outer
    } else {
      /declare GimmeSharing bool outer TRUE
    }
  }

  /if (!${GimmeSharing} && !${IsMyBot}) {
    /call notifyViaBCTell  ${ChatSender} "I have disabled Gimme sharing, please seek your supplies elsewhere"
    /return
  }

	| check if the requestor can be reached
	/if (!${Spawn[${ChatSender}].LineOfSight}) {
		/call notifyViaBCTell  ${ChatSender} "Where are you? I don't see you. Please move closer if you want me to give you something."
		/delay 10
		/return
	}	
	
	/if (${DebugGimme}) /echo RequestedItem IsModShard = ${Bool[${RequestedItem.Find[Modulation Shard]}]}
	/declare IsRequestedItemModShard bool local ${Bool[${RequestedItem.Find[Modulation Shard]}]}
	
	/call notifyViaBCTell  ${ChatSender} "${RequestedItem}, coming right up"
	/declare DiamondCoinName Diamond Coin
	/declare DCName DC
	/declare DiamondCoinsName Diamond Coins
	/declare DCRequested false
	/if (${DCName.Equal[${RequestedItem}]} || ${DiamondCoinName.Equal[${RequestedItem}]} || ${DiamondCoinsName.Equal[${RequestedItem}]}) {
		/varset RequestedItem ${DiamondCoinName}
	}	
	/if (${DebugGimme}) /echo IsMyBot = ${IsMyBot}
	/if (${DebugGimme}) /echo RequestedItem = ${RequestedItem}
	/if (${IsMyBot} && ${DiamondCoinName.Equal[${RequestedItem}]}) {
		/delay 1
		/echo Collecting Diamond Coins to give to ${ChatSender}
		/delay 1
		/if (${Window[InventoryWindow].DoOpen}) /echo Inventory Window Open
		/delay 5s ${Window[InventoryWindow].Open}
		/notify InventoryWindow IW_Subwindows tabselect 5
		/delay 1s
		/notify InventoryWindow AltCurr_PointList listselect 8
		/delay 1s
		/notify InventoryWindow IW_AltCurr_ReclaimButton leftmouseup
		/delay 1s
		/notify InventoryWindow IW_AltCurr_CreateItemButton leftmouseup
		/delay 1s
		/notify QuantityWnd QTYW_Accept_Button leftmouseup
		/delay 3s ${Bool[${Cursor.ID}]}
		/if (${Window[InventoryWindow].Child[IW_AltCurrPage].Open}) /if (${Window[InventoryWindow].DoClose}) /echo Inventory Window Closed
	} else /if (${IsMyBot} && (${RequestedItem.Equal[platinum]} || ${RequestedItem.Equal[pp]} || ${RequestedItem.Equal[plat]})) {
		/if (${Me.Platinum} > 0) {
			/delay 1
			/echo Collecting Plat to give to ${ChatSender}
			/delay 1
			/if (${Window[InventoryWindow].DoOpen}) /echo Inventory Window Open
			/delay 5s ${Window[InventoryWindow].Open}
			/notify InventoryWindow IW_Money0 leftmouseup
			/delay 1s
			/notify QuantityWnd QTYW_Accept_Button leftmouseup
			/delay 1s
			/varset platOnCursor true
		} else {
			/delay 3s
			/call notifyViaBCTell  ${ChatSender} "I'm all out of ${RequestedItem}"
		}
	} else /if (${Bool[${FindItem[=${RequestedItem}]}]} && !${IsRequestedItemModShard}) {
		/if (${DebugGimme}) /echo Found item ${RequestedItem}
		/declare IsNoRent bool local ${Bool[${FindItem[=${RequestedItem}].NoRent}]}
		/if (${DebugGimme}) /echo Item is NoRent = ${IsNoRent}
		/if (${DebugGimme}) /echo IsMyBot = ${IsMyBot}		
		/if (${IsNoRent} || ${IsMyBot}) {
			/ItemNotify "${RequestedItem}" leftmouseup
			/delay 2s ${Bool[${Cursor.ID}]}
		} else {
			/delay 2s
			/tell ${ChatSender} Only temporary items can be requested
			/return
		}
	} else /if (${Bool[${FindItem[=Summoned: ${RequestedItem}]}]}) {
		/ItemNotify "Summoned: ${RequestedItem}" leftmouseup
		/delay 3s ${Bool[${Cursor.ID}]}
    /delay 1s
		
	} else {
	
		/if (${DebugGimme}) /echo Summoning ${RequestedItem}
		/declare RequestedItemString string local ${RequestedItem}
		/declare RequestedItemStringWithoutSummoned string local ${RequestedItemString.Replace["Summoned: ",]}
		/declare SummoningItem bool local true
		/echo ${RequestedItem}
		/if (${IsRequestedItemModShard}) {
      /bc A request for Modulation shards has been made, please pause for a moment.
      /delay 2s
      /bc Deleting old Mulation Shards, watch your cursor.
			|get rid of old mod rods, to remote then local
		  /bca ItemDeleteSummoned ${RequestedItem}
      /call ItemDeleteSummoned "${RequestedItem}"
      /call ClearCursor
		
    }
		/if (${Bool[${Me.Book[${RequestedItem}]}]} || ${Bool[${Me.AltAbility[${RequestedItem}]}]}) {

			/if (${DebugGimme}) /echo casting "${RequestedItem}"
        /call check_ReadySimple "${RequestedItem}"
        /if (${c_Ready}) {
          /call castSimpleSpell "${RequestedItem}" ${Me.ID}
        }     
    } else /if (${Bool[${Me.Book[Summon: ${RequestedItem}]}]}) {

			/if (${DebugGimme}) /echo casting "Summon: ${RequestedItem}"
      /call check_ReadySimple "Summon: ${RequestedItem}"
      /if (${c_Ready}) {
        /call castSimpleSpell "Summon: ${RequestedItem}" ${Me.ID}
      }
    
		
		} else /if (${Bool[${Me.Book[Summon ${RequestedItemStringWithoutSummoned}]}]}) {
		
    	/if (${DebugGimme}) /echo casting "Summon ${RequestedItemStringWithoutSummoned}"
  
      /call check_ReadySimple "Summon ${RequestedItemStringWithoutSummoned}"
      /if (${c_Ready}) {
        /call castSimpleSpell "Summon ${RequestedItemStringWithoutSummoned}" ${Me.ID}
      }
    	/varset SummonSpellCast "Summon ${RequestedItemStringWithoutSummoned}"
		
    } else /if (${Bool[${Me.Book[${RequestedItemStringWithoutSummoned}]}]} || ${Bool[${Me.AltAbility[${RequestedItemStringWithoutSummoned}]}]}) {
		
    	/if (${DebugGimme}) /echo casting ${RequestedItemStringWithoutSummoned}
      /call check_ReadySimple "${RequestedItemStringWithoutSummoned}"
      /if (${c_Ready}) {
        /call castSimpleSpell "${RequestedItemStringWithoutSummoned}" ${Me.ID}
      }      
	   
  
  	} else /if (${Bool[${RequestedItem.Find[Sanguine Mind Crystal]}]} && ${Bool[${Me.AltAbility[Sanguine Mind Crystal]}]}) {
			/if (${DebugGimme}) /echo casting Sanguine Mind Crystal
      /call check_ReadySimple "Sanguine Mind Crystal"
      /if (${c_Ready}) {
         /call castSimpleSpell "Sanguine Mind Crystal" ${Me.ID}
      }          
     
			
		} else {
			/delay 2s
			/call notifyViaBCTell  ${ChatSender} "Spell ${RequestedItem} not found"
			/varset SummoningItem false
		}
		/if (${SummoningItem}) {
        |we delay 1 sec after cusror id says it has something due to timing issues
        /delay 15s ${Bool[${Cursor.ID}]}
        /delay 1s

    } 
		/if (${DebugGimme}) /echo Summoned ${RequestedItem} ${SummoningItem}
		
		| If the item is a modulation shard, tell everyone to put it in their bag
		| and flush the other events that have piled up as this is a long casting spell
		/if (${IsRequestedItemModShard}) {
      /bc Putting new Mulation Shards in bags.
     	/bca ItemDeleteSummoned ClearCursor
      /call ClearCursor
	    /doevents flush gimme
      /bc Done with Modulation shards
			/return
		
    }
	}
	
	/if ((${Cursor.ID} || ${platOnCursor}) && !${IsRequestedItemModShard}) {
		
    /Echo Gimmie: Getting target of requester
    /target pc ${ChatSender}
    /delay 10s ${Target.ID}==${Spawn[${ChatSender}].ID}

    /declare originalLoc string local ${Me.Loc}
		/if (${DebugGimme}) /echo IsClose = ${Bool[${Math.Distance[${senderLoc}]}<20]}
		/stick 12
		/while (${Math.Distance[${Spawn[${ChatSender}].Loc}]}>20) {
			/if (${Debug}) /echo Distance = ${Math.Distance[${senderLoc}]}
			/delay 1s
		}
		/if (${DebugGimme}) /echo Distance = ${Math.Distance[${senderLoc}]}
		/if (${DebugGimme}) /echo IsClose = ${Bool[${Math.Distance[${senderLoc}]}<20]}
		/click left target
		/delay 3s ${Window[TradeWnd].Open}
		/declare tradeTries int local 0
		/while (${Window[TradeWnd].Open} && ${tradeTries} < 2) {
			/notify TradeWnd TRDW_Trade_Button leftmouseup 
			/delay 5
			/bct ${Target.CleanName} //notify TradeWnd TRDW_Trade_Button leftmouseup 
			/delay 1s
			/varset tradeTries ${Math.Calc[${tradeTries} + 1]}
      /echo tradeTries=${tradeTries}
	  }
    /if (${Window[TradeWnd].Open}) {
      /echo Cancelling the trade with ${ChatSender}
      /t ${ChatSender} Cancelling the trade. Please turn on auto accept trades using /plugin mq2autoaccepttrades.
      /notify TradeWnd TRDW_Cancel_Button leftmouseup 
    }
		/call ClearCursor
		| Move back to original location
		/if (${Stick.Active}) /squelch /stick off
		/if (${Math.Distance[${originalLoc}]}>20) /call MoveToLoc ${originalLoc} 50 20
	} else /if (!${IsRequestedItemModShard}) {
		/call notifyViaBCTell  ${ChatSender} "Sorry, I don't have a ${RequestedItem} and couldn't summon one for you. The spell/AA may be on cooldown."
	} 
	
	
/return
sub notifyViaBCTell(targetToTell, messageToSend)
  /declare IsTargetMyBot bool local False
	/varset IsTargetMyBot ${Bool[${Select[${targetToTell}, ${NetBots.Client}]}]}		

   /if (${IsTargetMyBot}) {

      /bct ${targetToTell} ${messageToSend}

    } else {
  
      /tell ${targetToTell} ${messageToSend}
    }

/return

|----------------------------------------------------------------------------|
|- Whenever nothing else is going on will check if the toon has all the items in the gimme list
|- and request items it doesn't have from the target character
|- Install Instructions:                                   
|- Add this SUB to the bottom of e3 Includes/e3_Basics.inc 
|- Add subroutine check for the appropriate classes in e3 Macro Inis/Advanced Settings.ini                  
|-  ex:   ENC Function#10=check_Gimme                     
|- Add the below setting to your character.ini                       
|-  [Gimme]                                                 
|-  Gimme=CharacterName|ItemName|RetryTime
|-  Gimme=CharacterName|ItemName|RetryTime
|- Where the item is the item you want, the CharacterName is your supplier
|- and retry time is how long to wait before asking that character for
|- that item again (items must be acquired in order)
|- Example Config:
|- [Gimme]
|- Gimme=Element|Lava Orb|30s
|- Gimme=Focus|Sanguine Mind Crystal III|300s
|- Gimme=Focus|Azure Mind Crystal|300s
|----------------------------------------------------------------------------|
SUB check_Gimme
	/if (${Debug}) /echo |- check_Gimme ==>
  /if (${Waiting4Rez}) /return
  /if (${Bool[${Me.Buff[Resurrection Sickness]}]}) /return
	/declare DebugCheckGimme local false
	/if (!${Defined[GimmeEnabled]}) /declare GimmeEnabled bool outer ${Bool[${Ini[${Character_Ini},Gimme]}]}
    /if (${GimmeEnabled} && !${Bool[${Cursor.ID}]} && !${medBreak} && !${Me.CombatState.Equal[DEBUFFED]} && !${Me.Invis} && ${Me.PctHPs} == 100 && ${Me.PctAggro} < 1 && !${Me.CombatState.Equal[COMBAT]} && !${Assisting} && !${Me.Moving} && !${Me.Combat}) {   
		/if (!${Defined[Gimmies]}) /call IniToArrayV "${Character_Ini},Gimme,Gimme#" Gimmies
		/if (!${Defined[gimmeCharacter]}) /declare gimmeCharacter string local NULL
		/if (!${Defined[gimmeItem]}) /declare gimmeItem string local NULL
		/if (!${Defined[gimmeTimeout]}) /declare gimmeTimeout timer local NULL
		| Loop through the string, then loop through each of the items on that key		
		/declare i int local
		/declare IsTargetMyBot bool local false
		/for i 1 to ${Gimmies.Size}
			/varset gimmeCharacter ${Gimmies[${i}].Arg[1,|]}
			/varset gimmeItem ${Gimmies[${i}].Arg[2,|]}
			/varset gimmeTimeout ${Gimmies[${i}].Arg[3,|]}
			
			| If it's my bot, check if the target bot is available to gimme
			/varset IsTargetMyBot ${Bool[${Select[${gimmeCharacter}, ${NetBots.Client}]}]}			
			/if (${DebugCheckGimme}) /echo ${gimmeCharacter} IsTargetMyBot=${IsTargetMyBot}
			/if (${IsTargetMyBot} && (!${Spawn[${gimmeCharacter}].LineOfSight} || ${Bool[${NetBots[${gimmeCharacter}].Casting}]} || ${NetBots[${gimmeCharacter}].Attacking} || ${NetBots[${gimmeCharacter}].Moving} || !${NetBots[${gimmeCharacter}].InZone})) {
				/if (${DebugCheckGimme}) /echo ${gimmeCharacter} is busy
				/if (${DebugCheckGimme}) /echo ${gimmeCharacter} Netbots = 	${NetBots[${gimmeCharacter}].PctHPs}
				/if (${DebugCheckGimme}) /echo ${gimmeCharacter} is Casting ${NetBots[${gimmeCharacter}].Casting}
				/if (${DebugCheckGimme}) /echo ${gimmeCharacter} is Attacking ${NetBots[${gimmeCharacter}].Attacking}
				/if (${DebugCheckGimme}) /echo ${gimmeCharacter} PctMana ${NetBots[${gimmeCharacter}].PctMana}
				/if (${DebugCheckGimme}) /echo ${gimmeCharacter} PctHPs ${NetBots[${gimmeCharacter}].PctHPs}
			} else {
				/if (!${Defined[GimmeTimer${i}]}) /declare GimmeTimer${i} timer outer 0
				/if (!${Bool[${FindItem[=${gimmeItem}]}]} && ${GimmeTimer${i}} == 0 && ${Bool[${Spawn[${gimmeCharacter}]}]}) {
					/if (${Bool[${Spawn[pc ${gimmeCharacter}]}]}) {
						/echo ==> Gimme: Hey ${gimmeCharacter} Gimme a ${gimmeItem}
						/delay 1
            /call notifyViaBCTell ${gimmeCharacter} "Gimme ${gimmeItem}"
					}
					/varset GimmeTimer${i} ${gimmeTimeout}
					| Minimum of 10s delay between requests
					/delay 10s
					/return
				}
			}
		/next i
	}
	/if (${Debug}) /echo <== check_Gimme -|
/RETURN

|----------------------------------------------------------------------------|
|- Whenever nothing else is going on it will check to see if the toon has all 
|- of the items in the supply list. If they don't, it will cast the spell to 
|- create the item.
|- Install Instructions:                                   
|- Add this SUB to the bottom of e3 Includes/e3_Basics.inc 
|- Add subroutine check for the appropriate classes in e3 Macro Inis/Advanced Settings.ini                  
|-  ex:   MAG Function#10=check_Supply
|- Add the below setting to your character.ini
|-  [Supply]                                                 
|-  Supply=ItemName|SpellName|RetryTime|GemSlot
|-  Supply=ItemName|SpellName|RetryTime|GemSlot
|- Where the item is the item you want, the spell name is the spell to cast to
|- create that item (for AAs, use the alt id), retry time is how long to wait 
|- before trying to create that item again if you don't have it, and gem slot
|- is the gem you want to memorize the spell to. If the spell/AA doesn't need
|- to be memorized, just leave the gem parameter blank.
|- Example: Supply=Lava Orb|Summon: Lava Orb|10s|8
|- Example: Supply=Summoned: Large Modulation Shard|Large Modulation Shard|10s
|----------------------------------------------------------------------------|
SUB check_Supply
	/if (${Debug}) /echo |- check_Supply ==>
  /if (${Waiting4Rez}) /return
  /if (${Bool[${Me.Buff[Resurrection Sickness]}]}) /return
  | Extra checks here because sometimes Waiting4Rez doesn't seem to short out supply
  /if (!${Bool[${InvSlot[pack8].Item.ID}]}) /return 
  /if (${Me.MaxHPs} < 10000) /return
	/if (!${Defined[SupplyEnabled]}) /declare SupplyEnabled bool outer ${Bool[${Ini[${Character_Ini},Supply]}]}
  
  /if (!${SupplyEnabled}) /goto :endsupply
  /if (${Bool[${Cursor.ID}]}) /goto :endsupply
  /if (${Me.CombatState.Equal[DEBUFFED]}) /goto :endsupply
  /if (${Me.CombatState.Equal[COMBAT]}) /goto :endsupply
  /if (${Me.Invis}) /goto :endsupply
  /if (${Me.Moving}) /goto :endsupply
  /if (${Me.Combat}) /goto :endsupply
  /if (${Assisting}) /goto :endsupply
  /if (${Me.PctAggro} > 0) /goto :endsupply
 
  /if (${Me.PctMana} == 100 && ${Me.PctHPs} == 100 ) { 
		
    /if (!${Defined[Supply]}) /call IniToArrayV "${Character_Ini},Supply,Supply#" Supply
		/declare i int local
		/if (!${Defined[supplyItem]}) /declare supplyItem string local NULL
		/if (!${Defined[supplySpell]}) /declare supplySpell string local NULL
		/if (!${Defined[supplyTimeout]}) /declare supplyTimeout timer local NULL
		/if (!${Defined[supplyGem]}) /declare supplyGem int local NULL
    /if (!${Defined[supplyQuantity]}) /declare supplyQuantity int local NULL	
    | Loop through the string, then loop through each of the items on that key	
		/for i 1 to ${Supply.Size}
			/varset supplyItem ${Supply[${i}].Arg[1,|]}
			/varset supplySpell ${Supply[${i}].Arg[2,|]}
			/varset supplyTimeout ${Supply[${i}].Arg[3,|]}
			/varset supplyGem ${Supply[${i}].Arg[4,|]}
      /if (${Supply[${i}].Arg[5,|]}) {
        /varset supplyQuantity ${Supply[${i}].Arg[5,|]}
      } else {
        /varset supplyQuantity 1
      }
			/if (!${Defined[SupplyTimer${i}]}) /declare SupplyTimer${i} timer outer 0
      /if (${FindItemCount[${supplyItem}]} < ${supplyQuantity} && ${SupplyTimer${i}} == 0 && ) {
        /if (${FindItem[${supplyItem}].Lore} && ${supplyQuantity} > 1 && !${supplyItem.Equal[Summoned: Large Modulation Shard]}) {
          /if (${Debug}) /echo Supply item ${supplyItem} is Lore but has a specified quantity of ${supplyQuantity}
          /return
        }
				/echo ==> Supply: Creating a ${supplyItem} using ${supplySpell} need ${supplyQuantity}
				/delay 1
				/tar ${Me}
				/delay 1
				/declare previousSpell string local ${Me.Gem[${supplyGem}]}
				| If no spell gem specified, use default set in casting


        | If the item is a modulation shard, tell the group to delete their old ones
				/if (${supplyItem.Find[Modulation Shard]}) {
            |get rid of old mod rods, to remote then local
            /bc A request for Modulation shards has been made, please pause for a moment. Starting in 4 seconds
            /delay 4s
            /bc Deleting old Mulation Shards, watch your cursor.
            /bca ItemDeleteSummoned ${supplyItem}
            /call ItemDeleteSummoned "${supplyItem}"
            /delay 2s
				}

        /declare j int local
        /for j 1 to ${supplyQuantity}
				/if (${supplyGem} == 0 || ${supplyGem} == NULL) { 
           
           /call check_ReadySimple "${supplySpell}"
           /if (${c_Ready}) {

            /echo [${Time}]: Supply trying to get a:"${supplySpell}" 
            /call castSimpleSpell "${supplySpell}" ${Me.ID}

           }
           
       	} else {
           /echo [${Time}]: Supply with Gem specific: ${supplySpell}/Gem|${supplyGem}
           /call check_ReadySimple "${supplySpell}" ${supplyGem}
           /if (${c_Ready}) {
              /call castSimpleSpellBase "${supplySpell}/Gem|${supplyGem}" ${Me.ID} False
           }
				}
				|/delay 20s ${Bool[${Cursor.ID}]}
        /call ClearCursor
        /delay 1s
        /if (${FindItemCount[${supplyItem}]} >= ${supplyQuantity}) {
          /goto :supplyFinished
        }
        /next j
        :supplyFinished
  		  
				| If the item is a modulation shard, tell everyone to put it in their bag
				/if (${supplyItem.Find[Modulation Shard]}) {
          	/bc Putting new Mulation Shards in bags.
            /bca ItemDeleteSummoned ClearCursor
            /call ClearCursor
            |if people have bugged us for a shard as we deleted them all, flush out the event buffer
            /doevents flush gimme
            /bc Done with Modulation shards
      	}
				| Memorize the previous spell if needed
				/if (${Bool[${previousSpell}]}) {
					/delay 1s
					/echo ==> Supply: Memorizing ${previousSpell} to gem ${supplyGem}.
					/call memorize_spell "${previousSpell}" "${supplyGem}"
				}
				/varset SupplyTimer${i} ${supplyTimeout}
				/return
			}
		/next i
	}
  :endsupply
	/if (${Debug}) /echo <== check_Supply -|
/RETURN

|----------------------------------------------------------------------------|
|- Author: Sirhopsalot
|- Collects the items from all the members of your group, use /bc Collect RequestedItem
|- This feature uses Gimme Supply and supports the same item name short versions
|- Examples:
|- Collect diamond coins, use /bc Collect DC
|- Collect plat, use /bc Collect pp
|- Collect Habanero Peppers, use /bc Collect Habanero Pepper
|- Install Instructions:                                   
|- 1) Add this SUB to the bottom of e3 Includes/e3_Basics.inc 
|- 2) Add /doevents collect to Sub basics_Background_Events
|- Add Alias (optional):
|- /alias /collect /bc Collect
|- Allows skipping the /bc, e.g. /Collect DC
|----------------------------------------------------------------------------|
#event collect "<#1#> Collect #2#"
SUB event_collect(line, ChatSender, RequestedItem)
  /if (${Me.Name.Equal[${ChatSender}]}) {
    /declare i int local
    /for i 1 to ${Group.Members}
      /t ${Group.Member[${i}]} Gimme ${RequestedItem}
      /delay 4s
    /next i 
  }
/RETURN

|------------------------------------------------------------------------|
|- LinkLoot event 
|- Written by Psychosis of Project Lazarus								
|- Additional help from Grok and Kreegoth								
|- e3 integration by Sirhopsalot
|- Install Instructions:   
|- Place this function in e3_Basics.inc
|- add /doevents LinkLoot to basics_Background_Events in e3_Basics.inc
|- Usage:
|- /bc LinkLoot bag channel
|- /bc LinkLoot 1 2 // this would link all contents of bag 1 to Raid
|- Alias Shortcut:
|- /alias /LinkLoot /bc LinkLoot 
|- Alias Usage: /LinkLoot 1 1
|------------------------------------------------------------------------|
#EVENT LinkLoot "<#1#> LinkLoot #2# #3#"
SUB EVENT_LinkLoot(line, chatSender, bag, channel)
	/declare DebugLinkLoot bool local false

	/if (${chatSender.Equal[${Me.Name}]} == FALSE) {
		/if (${DebugLinkLoot}) /echo {chatSender.Equal[${Me.Name}]} = ${chatSender.Equal[${Me.Name}]}
		/return
	}

	/if (!${bag}) {
		/Echo Example Usage: /mac lootlink 1 2 -- This would link all contents of bag 1, to RAID
		/Echo Example Usage: The first is your bag number, the second is your channel output number
		/Echo Channel List: 1=Group, 2=Raid, 3=Guild
		/return
	}

	/if (${DebugLinkLoot}) /echo {bag} = ${bag}
	/if (${DebugLinkLoot}) /echo {channel} = ${channel}

	/declare Bag int ${bag}
	/declare Channel string ${channel}
	/declare varname int local
	/declare itemlist string local
	/declare itemlist_stack string local
	/for varname 1 to ${InvSlot[pack${Bag}].Item.Container}
		/if (${InvSlot[pack${Bag}].Item.Item[${varname}].ID}) {
			/varset itemlist ${itemlist}${LinkDB[${InvSlot[pack${Bag}].Item.Item[${varname}]}]}|
			/varset itemlist_stack ${itemlist_stack}${InvSlot[pack${Bag}].Item.Item[${varname}].Stack}|
		}
	/next varname
	/declare a int 1
	/declare b ${itemlist.Count[|]}	
	/if (${DebugLinkLoot}) /echo {itemlist.Count[|]} = ${itemlist.Count[|]}

	/if (${Channel} == 1) {
		/if (${b} == 10) {
			/bc Linking Bag [#${Bag}] to Group
			/g -- ITEMS IN BAG [#${Bag}] --
			/g	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/g ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/g ${itemlist_stack.Token[7,"|"]}x ${itemlist.Token[7,"|"]} - ${itemlist_stack.Token[8,"|"]}x ${itemlist.Token[8,"|"]} - ${itemlist_stack.Token[9,"|"]}x ${itemlist.Token[9,"|"]}
			/g ${itemlist_stack.Token[10,"|"]}x ${itemlist.Token[10,"|"]}
			/g ----
		} else /if (${b} == 9) {
			/bc Linking Bag [#${Bag}] to Group
			/g -- ITEMS IN BAG [#${Bag}] --
			/g	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/g ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/g ${itemlist_stack.Token[7,"|"]}x ${itemlist.Token[7,"|"]} - ${itemlist_stack.Token[8,"|"]}x ${itemlist.Token[8,"|"]} - ${itemlist_stack.Token[9,"|"]}x ${itemlist.Token[9,"|"]}
			/g ----
		} else /if (${b} == 8) {
			/bc Linking Bag [#${Bag}] to Group
			/g -- ITEMS IN BAG [#${Bag}] --
			/g	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/g ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/g ${itemlist_stack.Token[7,"|"]}x ${itemlist.Token[7,"|"]} - ${itemlist_stack.Token[8,"|"]}x ${itemlist.Token[8,"|"]}
			/g ----
		} else /if (${b} == 7) {
			/bc Linking Bag [#${Bag}] to Group
			/g -- ITEMS IN BAG [#${Bag}] --
			/g	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/g ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/g ${itemlist_stack.Token[7,"|"]}x ${itemlist.Token[7,"|"]}
			/g ----
		} else /if (${b} == 6) {
			/bc Linking Bag [#${Bag}] to Group
			/g -- ITEMS IN BAG [#${Bag}] --
			/g	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/g ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/g ----
		} else /if (${b} == 5) {
			/bc Linking Bag [#${Bag}] to Group
			/g -- ITEMS IN BAG [#${Bag}] --
			/g	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/g ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]}
			/g ----
		} else /if (${b} == 4) {
			/bc Linking Bag [#${Bag}] to Group
			/g -- ITEMS IN BAG [#${Bag}] --
			/g	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/g ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]}
			/g ----
		} else /if (${b} == 3) {
			/bc Linking Bag [#${Bag}] to Group
			/g -- ITEMS IN BAG [#${Bag}] --
			/g	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/g ----
		} else /if (${b} == 2) {
			/bc Linking Bag [#${Bag}] to Group
			/g -- ITEMS IN BAG [#${Bag}] --
			/g	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]}
			/g ----
		} else /if (${b} == 1) {
			/bc Linking Bag [#${Bag}] to Group
			/g -- ITEMS IN BAG [#${Bag}] --
			/g	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]}
			/g ----
		}
	}
	/if (${Channel} == 2) {
		/if (${b} == 10) {
			/bc Linking Bag [#${Bag}] to Raid
			/rs -- ITEMS IN BAG [#${Bag}] --
			/rs	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/rs ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/rs ${itemlist_stack.Token[7,"|"]}x ${itemlist.Token[7,"|"]} - ${itemlist_stack.Token[8,"|"]}x ${itemlist.Token[8,"|"]} - ${itemlist_stack.Token[9,"|"]}x ${itemlist.Token[9,"|"]}
			/rs ${itemlist_stack.Token[10,"|"]}x ${itemlist.Token[10,"|"]}
			/rs ----
		} else /if (${b} == 9) {
			/bc Linking Bag [#${Bag}] to Raid
			/rs -- ITEMS IN BAG [#${Bag}] --
			/rs	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/rs ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/rs ${itemlist_stack.Token[7,"|"]}x ${itemlist.Token[7,"|"]} - ${itemlist_stack.Token[8,"|"]}x ${itemlist.Token[8,"|"]} - ${itemlist_stack.Token[9,"|"]}x ${itemlist.Token[9,"|"]}
			/rs ----
		} else /if (${b} == 8) {
			/bc Linking Bag [#${Bag}] to Raid
			/rs -- ITEMS IN BAG [#${Bag}] --
			/rs	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/rs ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/rs ${itemlist_stack.Token[7,"|"]}x ${itemlist.Token[7,"|"]} - ${itemlist_stack.Token[8,"|"]}x ${itemlist.Token[8,"|"]}
			/rs ----
		} else /if (${b} == 7) {
			/bc Linking Bag [#${Bag}] to Raid
			/rs -- ITEMS IN BAG [#${Bag}] --
			/rs	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/rs ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/rs ${itemlist_stack.Token[7,"|"]}x ${itemlist.Token[7,"|"]}
			/rs ----
		} else /if (${b} == 6) {
			/bc Linking Bag [#${Bag}] to Raid
			/rs -- ITEMS IN BAG [#${Bag}] --
			/rs	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/rs ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/rs ----
		} else /if (${b} == 5) {
			/bc Linking Bag [#${Bag}] to Raid
			/rs -- ITEMS IN BAG [#${Bag}] --
			/rs	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/rs ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]}
			/rs ----
		} else /if (${b} == 4) {
			/bc Linking Bag [#${Bag}] to Raid
			/rs -- ITEMS IN BAG [#${Bag}] --
			/rs	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/rs ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]}
			/rs ----
		} else /if (${b} == 3) {
			/bc Linking Bag [#${Bag}] to Raid
			/rs -- ITEMS IN BAG [#${Bag}] --
			/rs	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/rs ----
		} else /if (${b} == 2) {
			/bc Linking Bag [#${Bag}] to Raid
			/rs -- ITEMS IN BAG [#${Bag}] --
			/rs	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]}
			/rs ----
		} else /if (${b} == 1) {
			/bc Linking Bag [#${Bag}] to Raid
			/rs -- ITEMS IN BAG [#${Bag}] --
			/rs	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]}
			/rs ----
		}
	}
	/if (${Channel} == 3) {
		/if (${b} == 10) {	
			/bc Linking Bag [#${Bag}] to Guild
			/gu -- ITEMS IN BAG [#${Bag}] --
			/gu	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/gu ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/gu ${itemlist_stack.Token[7,"|"]}x ${itemlist.Token[7,"|"]} - ${itemlist_stack.Token[8,"|"]}x ${itemlist.Token[8,"|"]} - ${itemlist_stack.Token[9,"|"]}x ${itemlist.Token[9,"|"]}
			/gu ${itemlist_stack.Token[10,"|"]}x ${itemlist.Token[10,"|"]}
			/gu ----
		} else /if (${b} == 9) {
			/bc Linking Bag [#${Bag}] to Guild
			/gu -- ITEMS IN BAG [#${Bag}] --
			/gu	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/gu ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/gu ${itemlist_stack.Token[7,"|"]}x ${itemlist.Token[7,"|"]} - ${itemlist_stack.Token[8,"|"]}x ${itemlist.Token[8,"|"]} - ${itemlist_stack.Token[9,"|"]}x ${itemlist.Token[9,"|"]}
			/gu ----
		} else /if (${b} == 8) {
			/bc Linking Bag [#${Bag}] to Guild
			/gu -- ITEMS IN BAG [#${Bag}] --
			/gu	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/gu ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/gu ${itemlist_stack.Token[7,"|"]}x ${itemlist.Token[7,"|"]} - ${itemlist_stack.Token[8,"|"]}x ${itemlist.Token[8,"|"]}
			/gu ----
		} else /if (${b} == 7) {
			/bc Linking Bag [#${Bag}] to Guild
			/gu -- ITEMS IN BAG [#${Bag}] --
			/gu	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/gu ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/gu ${itemlist_stack.Token[7,"|"]}x ${itemlist.Token[7,"|"]}
			/gu ----
		} else /if (${b} == 6) {
			/bc Linking Bag [#${Bag}] to Guild
			/gu -- ITEMS IN BAG [#${Bag}] --
			/gu	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/gu ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]} - ${itemlist_stack.Token[6,"|"]}x ${itemlist.Token[6,"|"]}
			/gu ----
		} else /if (${b} == 5) {
			/bc Linking Bag [#${Bag}] to Guild
			/gu -- ITEMS IN BAG [#${Bag}] --
			/gu	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/gu ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]} - ${itemlist_stack.Token[5,"|"]}x ${itemlist.Token[5,"|"]}
			/gu ----
		} else /if (${b} == 4) {
			/bc Linking Bag [#${Bag}] to Guild
			/gu -- ITEMS IN BAG [#${Bag}] --
			/gu	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/gu ${itemlist_stack.Token[4,"|"]}x ${itemlist.Token[4,"|"]}
			/gu ----
		} else /if (${b} == 3) {
			/bc Linking Bag [#${Bag}] to Guild
			/gu -- ITEMS IN BAG [#${Bag}] --
			/gu	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]} - ${itemlist_stack.Token[3,"|"]}x ${itemlist.Token[3,"|"]}
			/gu ----
		} else /if (${b} == 2) {
			/bc Linking Bag [#${Bag}] to Guild
			/gu -- ITEMS IN BAG [#${Bag}] --
			/gu	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]} - ${itemlist_stack.Token[2,"|"]}x ${itemlist.Token[2,"|"]}
			/gu ----
		} else /if (${b} == 1) {
			/bc Linking Bag [#${Bag}] to Guild
			/gu -- ITEMS IN BAG [#${Bag}] --
			/gu	${itemlist_stack.Token[1,"|"]}x ${itemlist.Token[1,"|"]}
			/gu ----
		}
	}
/RETURN

|**
  Author: Sirhopsalot

  Toggles manastone on/off
  Will automatically toggle back off when mana is 100%
  Can be toggled off while manastone is active

  Usage:
  Enable/disable manastone for one character: /t characterName stone toggle
  Enable/disable manastone for all characters: /bc stone toggle
  Enable/disable manastone for the group: /g stone toggle
  
  Install Instructions:                                   
  1) Add this SUB and check_StoneOn to the bottom of e3 Includes/e3_Basics.inc 
  2) Add /doevents manastoneToggle to Sub basics_Background_Events
  3) Add /call check_StoneOn to Sub basics_Background_Events
  Add Alias (optional):
      In a chat box, submit this to allow you to use the shortcut /stoneToggle
      /alias /stoneToggle /bc stone toggle
**|
#event manastoneToggle "#1# tells you, 'stone toggle'"
#event manastoneToggle "<#1#> stone toggle"
#event manastoneToggle "#1# tells the group, 'stone toggle'"
SUB event_manastoneToggle(line, ChatSender)
  /if (!${Defined[stoneOn]}) {
    /declare stoneOn bool outer TRUE
  } else /if (${stoneOn}) {
    /varset stoneOn FALSE
  } else {
    /varset stoneOn TRUE
  }

  /if (!${Bool[${FindItem[=Manastone]}]} && ${stoneOn}) {
    /varset stoneOn FALSE
  } else /if (${stoneOn}) {
    /docommand ${ChatToggle} Manastone on
  } else {
    /docommand ${ChatToggle} Manastone off
  }
/RETURN

|**
  Checks if the stoneOn variable is TRUE and clicks the manastone 10 times
  Sets stoneOn to false when the toon's mana reaches 100%
**|
SUB check_StoneOn
  /if (!${Defined[stoneOn]}) {
    /declare stoneOn bool outer FALSE
  }

  /if (!${Defined[HasManastone]}) {
    /declare HasManastone bool outer ${Bool[${FindItem[=Manastone]}]}
  }

  /if (!${Defined[HasCorruptedManastone]}) {
    /declare HasCorruptedManastone bool outer ${Bool[${FindItem[=Corrupted Manastone]}]}
  }

  /if (!${Defined[corruptedManastoneTimer]}) {
    /declare corruptedManastoneTimer timer outer 0
  }
  
  /if (${stoneOn} && ${HasCorruptedManastone}) {
    /if (${Me.PctMana} < 100 && ${Me.PctHPs} > 70 && ${Me.ItemReady[Corrupted Manastone]} && ${corruptedManastoneTimer} == 0) {
      /itemnotify "Corrupted Manastone" rightmouseup
      /varset corruptedManastoneTimer 62
    }
  }
  
  /declare i int local
  | hit the stone 10 times
  /for i 1 to 10
    /if (${stoneOn} && ${HasManastone} && ${Me.PctMana} < 100 && ${Me.PctHPs} > 70) {
      /itemnotify manastone rightmouseup
    }
  /next i

  /if (${stoneOn} && ${Me.PctMana} >= 100) {
    /varset stoneOn FALSE
    /docommand ${ChatToggle} Manastone off, mana 100%
  }
/RETURN

|-----------------------------------------------------------|
|- Eat and Drink items in order to keep your hunger/thirst -|
|- level below a certain level and not eat stat food       -|
|- Install Instructions:                                   -|
|- Add this SUB to the bottom of e3 Includes/e3_Basics.inc -|
|- Add subroutine check for the appropriate classes        -|
|- in e3 Macro Inis/Advanced Settings.ini                  -|
|-  ex:   DRU Function#12=check_Food                       -|
|- Add setting to your character.ini                       -|
|-  [Misc]                                                 -|
|-  AutoFood=On                                            -|
|-  Food=Loaf of Bread                                     -|
|-  FoodWarningStackSize=100                               -|
|-  Drink=Bottle of Milk                                   -|
|-  DrinkWarningStackSize=100                              -|
|-----------------------------------------------------------|
SUB check_Food
/if (${Debug}) /echo |-check_Food ==>
  /if (!${Defined[FoodOn]}) {
    /call iniToVarV "${Character_Ini},Misc,AutoFood" FoodOn bool outer
    /call iniToVarV "${Character_Ini},Misc,Food" cheapFood string outer
    /call iniToVarV "${Character_Ini},Misc,FoodWarningStackSize" cheapFoodWarningStackSize int outer
    /call iniToVarV "${Character_Ini},Misc,Drink" cheapDrink string outer
    /call iniToVarV "${Character_Ini},Misc,DrinkWarningStackSize" cheapDrinkWarningStackSize int outer
  }
  /if (${FoodOn} && !${Assisting}) {
    /if (${FindItem[${cheapFood}].ID} && (${Me.Hunger} < 4500)) {
      /useitem ${cheapFood}
      /delay 3
      /if (${Defined[cheapFoodWarningStackSize]} && ${FindItem[${cheapFood}].StackCount} < ${cheapFoodWarningStackSize}) {
        /docommand ${ChatToggle} Autofood - running low on ${cheapFood}
      }
    }
    /if (${FindItem[${cheapDrink}].ID} && (${Me.Thirst} < 4500)) {
      /useitem ${cheapDrink}
      /delay 3
      /if (${Defined[cheapDrinkWarningStackSize]} && ${FindItem[${cheapDrink}].StackCount} < ${cheapDrinkWarningStackSize}) {
        /docommand ${ChatToggle} AutoFood - running low on ${cheapDrink}
      }
    }
  }
/if (${Debug}) /echo <== check_Food -|
/RETURN

|-----------------------------------------------------------|
|- Uses Forage whenever nothing else is going on           -|
|- Install Instructions:                                   -|
|- Add this SUB to the bottom of e3 Includes/e3_Basics.inc -|
|- Add subroutine check for the appropriate classes        -|
|- in e3 Macro Inis/Advanced Settings.ini                  -|
|-  ex:   DRU Function#11=check_Forage                     -|
|- Add setting to your character.ini                       -|
|-  [Misc]                                                 -|
|-  AutoForage=On					                       -|
|-----------------------------------------------------------|
SUB check_Forage
/if (${Debug}) /echo |- check_Forage ==>
	/declare DebugForage false
	/if (${DebugForage}) /echo Forage On = ${Select[${Ini[${Character_Ini},Misc,AutoForage]}, On]}
	/if (!${Defined[ForageOn]}) /declare ForageOn string outer ${Select[${Ini[${Character_Ini},Misc,AutoForage]}, On]}
    /if (${ForageOn} && ${Me.AbilityReady[Forage]} && !${medBreak} && !${Me.CombatState.Equal[DEBUFFED]} && !${Me.Invis} && (${Me.MaxMana} == 0 || ${Me.PctMana} == 100) && ${Me.PctHPs} == 100 && ${Me.PctAggro} < 1 && !${Me.CombatState.Equal[COMBAT]} && !${Assisting}) {   
		/echo == Foraging ==
		/doability forage
		/delay 2s ${Bool[${Cursor.ID}]}
		/while (${Bool[${Cursor.ID}]}) {
			/call ClearCursor
			/delay 1s
		}
	}
/if (${Debug}) /echo <== check_Forage -|
/RETURN

|** Warn you when a bot is out of food/drink **|
#event outOfSomething "You are out of #1#."
SUB event_outOfSomething(line, Something)
  /docommand ${ChatToggle} [${Me.Name}] I'm out of ${Something}!
/return

|--------------------------------------------------------------------------------|
| Used in the summoning/deleting of mod shards. Doing this way to try and avoid
| character disconnect to character creation.  Doing an itemnotify while casting
| a spell will cause the toon to disconnect so we try and avoid that. 
| We want this "event" to fire in the normal event loop of e3 so the toon 
| is not doing anythin else. However we also want it to fire for only the non mage 
| party members while the mage will call this manually while in mid macro.
|---------------------------------------------------------------------------------|
#event ItemDeleteSummoned "<#1#> #2# ItemDeleteSummoned #3#"
SUB event_ItemDeleteSummoned(line, ChatSender, MyName, ItemString)

  /call ItemDeleteSummoned "${ItemString}"

/return
SUB ItemDeleteSummoned(ItemString)

  |didn't want to make ClearCusors its own event so shoved it in here for now.
  /if (${ItemString.Find[ClearCursor]}) {
        /call ClearCursor
        /return
  } 

   /if (${ItemString.Find[Summoned:]}) {
    
        /if (!${Bool[${FindItem[=${ItemString}]}]}) {
            /return
        } 
        /echo Trying to Deleting ${ItemString}
        /call ClearCursor
        /delay 1s
        |Found the issue of char disconnect. If you try and do a leftmouse up on an item and your casting
        |the server will disconnect you. So doing this out of bound of E3's event loop is dangerous
        /while (${Cast.Status.Find[C]}) {
          /delay 1
        }
        /itemnotify "${ItemString}" leftmouseup
        /delay 10s ${Bool[${Cursor.ID}]}
        /if (${Bool[${Cursor.ID}]} &&  ${Cursor.Name.Find[Summoned:]}) /destroy

    } 

/RETURN

|--------------------
|Method currently used in bard twisting, but can be useful for other areas.
|takes a snapshot of spells that were cast (non insta casts), to be used for later. 
|possibly update e3cast to also update this, but was written to be used with /twist
|as it doesn't go through e3_Cast
|------------------
sub check_PreviousSpell

  /if (!${Bool[${Me.Casting.ID}]}) /return
  /declare currentSpellCasting int local 0
  /varset currentSpellCasting ${Me.Gem[${Me.Casting}]}

  /if (${Bool[${currentSpellCasting}]}) {
    /varset previousSpellGemThatWasCast ${currentSpellCasting}
  }

/return

|---------------------------------------------------------------------------------|
| Centralized area to call methods that will be called every event loop
| Warning only put things that check very quickly if they should be called or not.
| putting methods that have complex checks will slow everything down
|---------------------------------------------------------------------------------|
Sub check_Basics
  /call check_ResistCounters
  /call check_PreviousSpell
  

/return


